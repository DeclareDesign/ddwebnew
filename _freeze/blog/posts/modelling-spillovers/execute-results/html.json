{
  "hash": "7f5a1b1e301ad32638cf02428a28af79",
  "result": {
    "markdown": "---\ntitle: \"Instead of avoiding spillovers, you can model them\"\nauthor: 'DeclareDesign Team'\ndate: \"2018-11-20\"\noutput:\n  html_document:\n    highlight: tango\n    theme: cerulean\n    code_folding: show\nbibliography: bib/blog.bib\n---\n\n\n\n\nSpillovers are often seen as a nuisance that lead researchers into error when estimating effects of interest. In a [previous post,](https://declaredesign.org/blog/2018-09-18-spillovers.html) we discussed sampling strategies to reduce these risks. A more substantively satisfying approach is to try to study spillovers directly. If we do it right we can remove errors in our estimation of primary quantities of interest and learn about how spillovers work at the same time. \n\nThis is important because spillovers are *part* of the overall effects of an intervention. If vaccination of one subject improves health outcomes for another, then this gain needs to be understood to assess the total benefits of vaccination. This is hard because we are not used to thinking of spillover effects as estimands, or to writing them in terms of potential outcomes, and so we generally do not think in terms of bias or power for spillover effects. But we can. \n\n# A spillover design and the idea of an indirect treatment\n\nWe declare a design based on the `spillover_designer` in the  `DesignLibrary` package.^[As with any design from the library, you  can always look at the underlying code using `get_design_code(spillover_designer())`.]\n\nIn this design there are 80 groups, each of size 3. Treatment is randomly assigned---ignoring groups. Outcomes do depend on group membership, however. In particular, any individual's outcome depends on the number of individuals in the group treated. A function (`dgp`) specifies how group assignments map into individual payoffs.^[This dgp function differs from what we examined before by having spillovers that are not complete: direct effects differ from indirect effects.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndgp <- function(i, Z, G) Z[i]/3 + sum(Z[G == G[i]])^2/5 + rnorm(1)\n\nspillover_design <- \n\n  declare_model(G = add_level(N = 80), \n                     j = add_level(N = 3, zeros = 0, ones = 1)) +\n  \n  declare_inquiry(direct = mean(sapply(1:240,  # just i treated v no one treated \n    function(i) { Z_i <- (1:240) == i\n                  dgp(i, Z_i, G) - dgp(i, zeros, G)}))) +\n  \n  declare_inquiry(indirect = mean(sapply(1:240, \n    function(i) { Z_i <- (1:240) == i           # all but i treated v no one treated   \n                  dgp(i, ones - Z_i, G) - dgp(i, zeros, G)}))) +\n  \n  declare_assignment(Z = complete_ra(N)) + \n  \n  declare_measurement(\n    neighbors_treated = sapply(1:N, function(i) sum(Z[-i][G[-i] == G[i]])),\n    one_neighbor  = as.numeric(neighbors_treated == 1),\n    two_neighbors = as.numeric(neighbors_treated == 2),\n    Y = sapply(1:N, function(i) dgp(i, Z, G))\n  ) +\n  \n  declare_estimator(Y ~ Z, \n                    inquiry = \"direct\", \n                    model = lm_robust, \n                    label = \"naive\") +\n  \n  declare_estimator(Y ~ Z * one_neighbor + Z * two_neighbors,\n                    term = c(\"Z\", \"two_neighbors\"),\n                    inquiry = c(\"direct\", \"indirect\"), \n                    label = \"saturated\", \n                    model = lm_robust)\n```\n:::\n\n\nThe key feature of this design is that units belong in **groups**. When a unit gets treated, the effect of the treatment spreads out across other group members (but no further). \n\nIn this kind of setting, we can say you get **indirectly** treated when someone in your group -- your \"neighbor\" -- gets treated. In this case, we might think of the **number of neighbors treated** in a given assignment as your indirect treatment. For three-member groups, this definition of spillovers implies every unit has at least six potential outcomes $Y_{z,n}$. For example, $Y_{1,2}$ is the potential outcome for a unit who is treated in a group where both other members are treated, while $Y_{1,0}$ is the potential outcome for a unit when they are the only member treated in their group.\n\nIf we plot the units in groups using colors for their individual treatment status and labeling them with the number of neighbors treated, one set of assignments for a sample of groups might look like this:\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](modelling-spillovers_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThere are two notable departures from the design we looked at before. First, we declare an estimand for indirect effects and not just for direct effects. For direct effects we focus on the effect of being treated given no neighbors are treated ($E[Y_{1,0} - Y_{0,0}]$). For indirect effects we focus on the effect for an individual of having everyone else treated given that they themselves are not treated ($E[Y_{0,2} - Y_{0,0}]$).^[In fact if you look a the design declaration we are a little more thorough and define the estimand in terms of the treatment status of *all individuals* and not just the in-group members.] Importantly, this **estimand** is defined in terms of potential outcomes rather than being dependent on a particular model. \n\nSecond, alongside the naive estimator, we use an estimator that seeks to model the direct and indirect effects directly. By modelling indirect effects in the estimation step, we can seek to estimate the average direct treatment effect without bias and conditional on the number of neighbors treated. \n\nIn this context, where the spillover mechanism is well-understood and captured by the statistical model, our modelling approach does a great job of removing bias. Here we show the estimated effects of being treated when no others are treated (direct effect) and of not being treated when all others are treated (indirect effect). We see the mean estimate (dashed blue line) is right on the mean estimand (solid red line) in both cases when we model the spillovers:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](modelling-spillovers_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\nPower for all estimates now looks like this:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in\nggplot2 3.3.4.\nâ„¹ Please use \"none\" instead.\n```\n:::\n\n::: {.cell-output-display}\n![](modelling-spillovers_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWe have great power for the naive estimator -- but only because it confidently delivers the wrong answer! The power from the saturated model is not so great, especially for the direct effect.\n\n# You can use assignment to improve power in the presence of spillovers\n\nOne approach to increase power for the direct effect is to tweak the assignment to control the number of groups that have one or two members treated. \n\nDoing this may produce tradeoffs, however, between power for direct effects and power for indirect effects. \n\nThe current assignment just assigns units to treatment with .5 probability, ignoring groups. We'll replace that step with a new assignment strategy where we directly control whether groups get 0, 1, or 2 members treated. (This kind of design is sometimes called a randomized saturation design.)\n\nWe declare a custom assignment that uses a two-stage procedure, in which we first assign groups to treatment densities, then assign units to treatment conditional on their group's density. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntwo_stage <- function(data, density_probs){\n  density <- with(data, cluster_ra(clusters = unique(G), \n                                   conditions = c(0,1,2),\n                                   prob_each = density_probs))\n  data$Z <- with(data, block_ra(blocks = G, block_m = density))\n  return(data)\n}\n```\n:::\n\n\nLet's compare two different first-stage approaches: one where we assign more of our groups to have 0 or 1 members treated, and another in which we assign more to have 0 or 2 members treated.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspillovers_assigned_1 <- \n  replace_step(\n    design = spillover_design, \n    step  =  4, \n    new_step = declare_assignment(handler = two_stage, \n                                  density_probs = c(.45,.45,.1)))\nspillovers_assigned_2 <- \n  replace_step(\n    design = spillover_design, \n    step  =  4, \n    new_step = declare_assignment(handler = two_stage, \n                                  density_probs = c(.45,.1,.45)))\n```\n:::\n\n\nNow power looks like this:\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](modelling-spillovers_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nWe see a large gain in power for the estimation of direct effects when assigning more groups to have 0 or 1 member treated, and a big loss when assigning fewer groups to those densities in favor of having 2 members treated. We see an opposite tradeoff for the estimation of indirect effects. Optimal assignment depends on the quantities of interest. See @baird2017optimal for a great treatment of these issues.\n\n\n# Some warnings\n\nWe got things right in part because we were right about the structure of spillovers. The estimation strategy did not assume much about the functional form of the spillovers but it *did* require being right about spillovers being contained within groups. If, in addition to the spillovers that we modeled, there were also spillovers between groups, then the estimation strategy would get things wrong in much the same way as the naive approach that ignored spillovers within groups got things wrong. So you need to use knowledge about the structure of spillovers. An interesting exercise is to alter the dgp function so that outcomes also depend on `Z[1]`---the treatment status of person number 1. How would that alter things? \n\nLess obvious, perhaps, things were easy here because the group sizes were homogeneous. Why does that matter? The reason is that in this example uniform assignment probabilities for the direct treatment translated into uniform assignment probabilities for the indirect treatments. But generally you cannot count on this. In this case, if groups were of heterogeneous size and treatment was randomly assigned, then units in big groups would be more likely to be exposed to treatment indirectly than units in small groups: a unit in a group of size 3 would be less likely to have two neighbors treated (`prob = .25`) than a unit in a group of size 4 (`prob = 3/8`). \nThis can produce bias if treatment effects also depend on group size.  To remove the bias you would need to take account of the fact that the indirect treatments were assigned with unequal propensities (even though the direct treatments were assigned to all units with the same probability!). This is a very similar issue to [one we discussed here](https://declaredesign.org/blog/biased-fixed-effects.html), and some of those approaches to addressing bias arising from heterogeneous (indirect) assignment propensities can also help in the spillover context.\n\nAlso not too obvious, even if direct treatments are assigned independently, assignment of indirect treatments might be clustered. For example everyone in a family gets indirectly treated together when one member gets directly treated. Given the possibly complex nature of clustering, it might make sense to use [randomization inference](https://egap.org/methods-guides/10-things-randomization-inference) for hypothesis testing is this setting.\n\nFor more on this topic, including strategies for estimating uncertainty given indirect treatment, see, for example, @aronow2017estimating.\n\n\n# References\n\n",
    "supporting": [
      "modelling-spillovers_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}