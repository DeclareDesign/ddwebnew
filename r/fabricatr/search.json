[{"path":[]},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"interest fostering open welcoming environment, contributors maintainers pledge making participation project community harassment-free experience everyone, regardless age, body size, disability, ethnicity, gender identity expression, level experience, nationality, personal appearance, race, religion, sexual identity orientation.","code":""},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes creating positive environment include: Using welcoming inclusive language respectful differing viewpoints experiences Gracefully accepting constructive criticism Focusing best community Showing empathy towards community members Examples unacceptable behavior participants include: use sexualized language imagery unwelcome sexual attention advances Trolling, insulting/derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical electronic address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"our-responsibilities","dir":"","previous_headings":"","what":"Our Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Project maintainers responsible clarifying standards acceptable behavior expected take appropriate fair corrective action response instances unacceptable behavior. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, ban temporarily permanently contributor behaviors deem inappropriate, threatening, offensive, harmful.","code":""},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within project spaces public spaces individual representing project community. Examples representing project community include using official project e-mail address, posting via official social media account, acting appointed representative online offline event. Representation project may defined clarified project maintainers.","code":""},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported contacting project team abuse@declaredesign.org. complaints reviewed investigated result response deemed necessary appropriate circumstances. project team obligated maintain confidentiality regard reporter incident. details specific enforcement policies may posted separately. Project maintainers follow enforce Code Conduct good faith may face temporary permanent repercussions determined members project’s leadership.","code":""},{"path":"https://declaredesign.org/r/fabricatr/CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 1.4, available http://contributor-covenant.org/version/1/4","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/advanced_features.html","id":"more-complicated-level-creation-with-variable-numbers-of-observations","dir":"Articles","previous_headings":"","what":"More complicated level creation with variable numbers of observations","title":"Advanced features","text":"add_level() can used create complicated patterns nesting. example, creating lower level data, possible use different N values higher level data: , city different number citizens. value N used create age variable automatically updates needed. result dataset 6 citizens, 2 first city 4 second. long N either number, vector length current lowest level data, add_level() know . also possible provide function N, enabling random number citizens per city: , city given random number citizens 1 6. Since sample() function returns vector length 2, like specifying 2 separate Ns example . also possible define N basis higher level variables . Consider following example: , city defined population, number citizens simulated data reflects sample 30% population. Although display first 6 rows brevity’s sake, first city 27 rows total. Finally, relying ID label higher level, also possible define N basis higher level’s length: , city random number citizens 1 10, need supply length higher level’s variable (case, ID label cities) sample function ensure one draw made per city.","code":"variable_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = c(2, 4), age = runif(N, 18, 70))   ) variable_data my_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = sample(1:6, size = 2, replace = TRUE), age = runif(N, 18, 70))   ) my_data variable_n <- fabricate(   cities = add_level(N = 5, population = runif(N, 10, 200)),   citizens = add_level(N = round(population * 0.3)) ) n_inherit <- fabricate(   cities = add_level(N = 5, population = runif(N, 10, 200)),   citizens = add_level(N = sample(1:10, length(cities), replace=TRUE)) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/advanced_features.html","id":"correlated-variables-with-custom-functions","dir":"Articles","previous_headings":"","what":"Correlated variables with custom functions","title":"Advanced features","text":"users might implemented drawing correlated variables generated functions amongst default R statistical distributions functions supplied fabricatr. function can made work correlate() provided accepts argument called quantile_y pass series quantiles draw distribution interest. example, might external data represents empirical distribution wish draw . use actual county level vote data 2016 US presidential election generate vote share correlated 0.34","code":"# Load external data: Thanks to Tony McGovern, https://github.com/tonmcg county_level_2016_results <- read.csv(url(\"https://raw.githubusercontent.com/tonmcg/County_Level_Election_Results_12-16/master/2016_US_County_Level_Presidential_Results.csv\"))  # Function that takes quantile_y and maps to the empirical quantiles of dataset custom_quantile <- function(data, quantile_y) {   round(ecdf(data)(quantile_y), 2) }  # Traditional fabricate() call: county_vote_data <- fabricate(   N = 500,   poverty_rate = runif(N, min = 0.01, max = 0.40),   dem_vote = correlate(custom_quantile,                         data = county_level_2016_results$per_dem,                        given = poverty_rate,                         rho = 0.3) )  cor(county_vote_data$dem_vote, county_vote_data$poverty_rate, method=\"spearman\")"},{"path":"https://declaredesign.org/r/fabricatr/articles/advanced_features.html","id":"tidyverse-integration","dir":"Articles","previous_headings":"","what":"Tidyverse integration","title":"Advanced features","text":"functions fabricatr take data return data, cross-compatible tidyverse workflow. example using magrittr’s pipe operator (%>%) dplyr’s group_by mutate verbs add new data. also possible use pipe operator (%>%) direct flow data fabricate() calls. Remember every fabricate() call can import existing data frames, every call returns single data frame.","code":"library(dplyr)  my_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = c(2, 3), age = runif(N, 18, 70))   ) %>%   group_by(cities) %>%   mutate(pop = n())  my_data my_data <-   data_frame(Y = sample(1:10, 2)) %>%   fabricate(lower_level = add_level(N = 3, Y2 = Y + rnorm(N))) ## Warning: `data_frame()` was deprecated in tibble 1.1.0. ## ℹ Please use `tibble()` instead. ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was ## generated. my_data"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"basics","dir":"Articles","previous_headings":"","what":"Basics","title":"Building and Importing Data","text":"Using fabricatr begins calling function fabricate(). fabricate() can used create single-level hierarchical data. three main ways call fabricate(): Making single-level dataset specifying many observations like Making single-level dataset importing data optionally modifying creating new variables Making hierarchical dataset.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"single-level-datasets-from-scratch","dir":"Articles","previous_headings":"","what":"Single-level datasets from scratch","title":"Building and Importing Data","text":"Making single-level dataset begins providing argument N, number representing number observations wish create, followed series variable definitions. Variables can defined using function access R. fabricatr provides several simple functions generating common types data. covered . Functions create subsequent variables can rely previously created variables, ensures variables can related one another: simple example makes use R’s built-runif command. rest tutorial assumes familiarity R basic data generating processes.","code":"library(fabricatr) my_data <- fabricate(N = 5, Y = runif(N), Y2 = Y * 5) my_data"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"filling-out-observations-","dir":"Articles","previous_headings":"","what":"Filling out observations.","title":"Building and Importing Data","text":"fabricate intended make rectangular data frames: means variable added level needs length. Failure provide equal-length variables result error. provide convenient helper function, recycle, help expand existing data fit length level. , let’s use existing month variable R generate data using month: month.abb contains months year: [“Jan”, “Feb”, “Mar”, …, “Dec”]. obvious although asking 20 observations, twelve months year. recycle automatically wrap month text resulting data frame 12 months “Jan” “Dec”, followed 8 months “Jan” “Aug”.","code":"month_gdp <- fabricate(   N = 20,   month_name = recycle(month.abb),   gdp_growth = rnorm(N, 0.5, 0.5) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"single-level-datasets-using-existing-data","dir":"Articles","previous_headings":"","what":"Single-level datasets using existing data","title":"Building and Importing Data","text":"Instead specifying argument N, users can specify argument data import existing datasets. dataset imported, subsequent variables access N, representing number observations imported data. makes easy augment existing data simulations based data. example, make use quakes dataset, built R, describes characteristics earthquakes coast Fiji. mag variable dataset contains richter magnitude earthquakes. expand data add variables modelling hypothetical fatalities insurance costs: Notice variable creation calls able make reference variables imported data set, newly created variables. Also, function calls can arbitrarily nested – variable fatalities uses several nested function calls.","code":"simulated_quake_data <- fabricate(   data = quakes,   fatalities = round(pmax(0, rnorm(N, mean = mag)) * 100),   insurance_cost = fatalities * runif(N, 1000000, 2000000) ) head(simulated_quake_data)"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"hierarchical-data","dir":"Articles","previous_headings":"","what":"Hierarchical data","title":"Building and Importing Data","text":"powerful use fabricatr create hierarchical (“nested”) data. example , create 5 countries, 10 provinces. also covariates country level (GDP per capita life expectancy) provincial level (presence natural resources, presence manufacturing industry): Several things can observed example. First, fabricate knows second add_level() command nested first level data. level gets ID variable, addition variables create. Second, meaning variable “N” changes. add_level() call countries, N 5. add_level() call provinces, N 10. resulting data, course, 50 observations. Finally, province-level variables created using draw_binary() function. function provided fabricatr make simulating discrete random variables simple. simulate data, can use fabricatr’s functions, R’s built-ins, custom functions wish. draw_binary() explained tutorial variable generation using fabricatr","code":"country_data <-   fabricate(     countries = add_level(       N = 5,       gdp_per_capita = runif(N, min = 10000, max = 50000),       life_expectancy = 50 + runif(N, 10, 20) + ((gdp_per_capita > 30000) * 10)     ),     provinces = add_level(       N = 10,       natural_resources = draw_binary(prob = 0.3, N = N),       manufacturing = draw_binary(prob = 0.7, N = N)     )   ) head(country_data)"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"adding-hierarchy-to-existing-data","dir":"Articles","previous_headings":"","what":"Adding hierarchy to existing data","title":"Building and Importing Data","text":"fabricatr also able import existing data nest hierarchical data . maybe useful , example, existing country-level data wish simulate data lower geographical levels purposes experiment plan conduct. Imagine importing country-province data simulated previous example. fabricate() returns data frame, simulated data can re-imported subsequent fabricate call, just like external data can . example, add third level data; 50 country-province observations, now 10 citizen-level observations. Citizen-level covariates like salary can draw country-level covariate province-level covariate. Notice syntax adding new nested level existing data different syntax adding new variables original dataset.","code":"citizen_data <-   fabricate(     data = country_data,     citizens = add_level(       N = 10,       salary = rnorm(         N,         mean = gdp_per_capita + natural_resources * 5000 + manufacturing * 5000,         sd = 10000       )     )   ) head(citizen_data)"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"modifying-existing-levels","dir":"Articles","previous_headings":"","what":"Modifying existing levels","title":"Building and Importing Data","text":"Suppose hierarchical data, wish simulate variables higher level aggregation. example, imagine import dataset containing citizens within countries, wish simulate additional country-level variables. fabricatr, can using modify_level() command. Let’s use country-province data earlier: can observe new variable created level aggregation chose – countries. Also, although N specified anywhere, modify_level() knows large N based number countries finds dataset. important, , ensure modify_level() command correctly assigned level interest. can also modify one level. , modify country-province-citizen data : assessing tells us modify_level(), let’s consider data simulated . creates new variable country level, country level average temperature. Subsequently, creates province level binary indicator whether province active conflict site. Provinces natural resources likely conflict simulation, drawing conclusions literature “resource curses”. infant mortality rate province able depend province level data just generated, country-level data: higher high-temperature areas (reflecting literature increased disease burden near equator) also higher conflict zones. Citizen access education also random, depends whether live conflict area. lot things learn example. First, ’s possible modify multiple levels. new variable created automatically propagate lower level data according – setting average temperature country, provinces, citizens provinces, value country. Values created one modify_level() call can used subsequent variables call, subsequent calls. , see use draw_binary(). Using function covered tutorial generating discrete random variables, linked .","code":"new_country_data <-   fabricate(     data = country_data,     countries = modify_level(average_temperature = runif(N, 30, 80))   )  head(new_country_data) new_citizen_data <-   fabricate(     data = citizen_data,     countries = modify_level(average_temperature = runif(N, 30, 80)),     provinces = modify_level(       conflict_zone = draw_binary(N, prob = 0.2 + natural_resources * 0.3),       infant_mortality = runif(N, 0, 10) + conflict_zone * 10 +         (average_temperature > 70) * 10     ),     citizens = modify_level(       college_degree = draw_binary(N, prob = 0.4 - (0.3 * conflict_zone))     )   )"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"averages-within-higher-levels-of-hierarchy","dir":"Articles","previous_headings":"","what":"Averages within higher levels of hierarchy","title":"Building and Importing Data","text":"powerful feature nested data fabricatr’s setup variable creating can access variables higher may want include mean value variable within group defined higher level hierarchy, example average income citizens within city. can ave(), built-R command: , can create citizen-level data relies data citizens within city. ave() takes two arguments: first, name variable averaging (case, income), second, name level grouping (case cities). R functions able group variables compute statistics interest also compatible fabricatr.","code":"ave_example <- fabricate(   cities = add_level(N = 2),   citizens = add_level(     N = 1:2, income = rnorm(N),     income_mean_city = ave(income, cities)   ) ) ave_example"},{"path":"https://declaredesign.org/r/fabricatr/articles/building_importing.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Building and Importing Data","text":"’ve seen fabricatr’s ability generate single-level hierarchical data, enough get started using package. , can explore modeling structure data reading tutorial panel cross-classified data using fabricatr bootstrap resample hierarchical data. , like learn modeling specific variables using fabricatr, can read tutorial common social science variables; technical manual generating discrete random variables; guide using data generation packages fabricatr.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"binary-outcomes-e-g--turnout","dir":"Articles","previous_headings":"","what":"Binary outcomes (e.g. turnout)","title":"Common Social Science variables","text":"simplest possible outcome interest binary outcome: one can either true false. example sort outcome social science research context whether subject performs action: person seek medical treatment? person turn vote? person write letter congressional representative? infrastructure project completed time? sorts questions typically modelled binary outcomes. “yes” “” answer question interest represented 1 (“yes”) 0 (“”) numerically. fabricatr, binary data can easily modeled draw_binary() function: draw_binary requires supply two pieces data: prob, specifies either single probability vector probabilities (one unit), probability getting “1” simulated data. instance, modeling turnout rate 40%. Second, requires N, specifies many observations create. also possible specify probability stochastically. Imagine wish model population individuals age 40 low turnout rate, individuals age 40 high turnout rate. simple fabricatr: example introduces new functions. First, can wrap multiple variable creation commands fabricate call. ensure result data frame, variable creation command access previous variables. Second, see can model age using R’s built-runif function. like information modeling statistical distributions R, see ?Distributions manual page. Third, see model turnout probability statistically; user age 40, receive turnout probability 0.4. , receive turnout probability 0.7. noted introduction tutorial, target audience tutorial someone interested common social science outcome variables, without strong background thinking modelling variables. feel comfortable modelling need learn specify variables fabricatr, please see tutorial variable generation fabricatr. need information modeling structure data implementing multi-level models, panel data, cross-classified data fabricatr, please see tutorial building importing data.","code":"voter_turnout = draw_binary(prob = 0.4, N = 100)  table(voter_turnout) population <- fabricate(   N = 100,   age = round(runif(N, 18, 85)),   turnout = draw_binary(prob = ifelse(age < 40, 0.4, 0.7), N=N) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"ordered-data-e-g--satisfaction","dir":"Articles","previous_headings":"","what":"Ordered data (e.g. satisfaction)","title":"Common Social Science variables","text":"type data generated many survey questions “ordered”. Ordered data includes “Likert scale”, used respondents survey report outcome logical ordering lowest highest necessarily measured numerically comparable terms. Consider basic question like “approve mayor’s job performance?”. many ways measure respondent’s answer question, one common offering respondent choice “Strongly Disapprove”, “Disapprove”, feel “Neutral”, “Approve”, “Strongly Approve”. five point scale ordered data. simulating ordered data, typically think problem differently, two-step process. first step assign respondent score range, second step translate score categories ordered variable. call first step “latent variable”. real survey, never see latent variable, ordered data outcome. can rely latent variable help shape simulated data. generate simulated latent variable translate simulated ordered variable, like :  graph, respondents (“density” represented height curve) neutral mayor, relatively hold extreme opinions. generated “normal” latent variable respondents translate ordered outcome. simplest normal variable “standard normal”, random variable whose mean (center) 0, whose standard deviation (spread) 1. , although shown graph , dashed lines divide ordered outcomes located -1.5, -0.5, 0.5, 1.5. course also possible affect center spread question:  Although thinking ordered data latent context may seem strange first, actually generating ordered data outcome fabricatr quite easy: Let’s look draw_ordered example. draw_ordered requires three pieces information us: x (latent variable), breaks (places latent variable divide categories ordered outcome), break_labels (label resulting ordered outcome). x, use rnorm command generate 100 standard normal draws representing respondents. breaks break_labels, mark label breaks . appeal fabricatr can create relationships variables, let’s imagine slightly complex data general mayor well liked members political party, members opposite political party. , ’ll need assign respondents political party (’ll mark mayor’s political party “1” opposition political party “0”) generate latent variable. First, let’s visualize latent variable:  , colors indicate two parties. see members red party disagree mayor, overwhelming majority , vice versa blue party. Now, let’s put visualization action: example little complex. can see use fabricate wrapper function, described detail Building Importing Data guide. Additionally, latent variable x complex. Let’s consider formula variable specified. know latent variable space -1.5 -0.5 indicates “Disagree”. respondents mayor_copartisan equal 0 (mayor’s political party), preference standard normal draw centered \\(-1 + (2 * 0) = -1\\). respondents mayor_copartisan equal 1 (mayor’s political party), preference standard normal draw centered \\(-1 + (2 * 1) = 1\\) – “Agree”. easy play location breaks, labels breaks, format underlying latent variable. ’s example latent variable “uniform” – equal likelihood choosing options: Users new R programmming language want know statistical distributions beyond norm unif distributions used , run command ?Distributions R console.","code":"mayor_approval <- draw_ordered(x = rnorm(n = 100),                                breaks = c(-1.5, -0.5, 0.5, 1.5),                                break_labels = c(\"Strongly Disagree\", \"Disagree\",                                                 \"Neutral\", \"Agree\",                                                 \"Strongly Agree\"))  table(mayor_approval) respondent_data <- fabricate(   N = 100,   mayor_copartisan = draw_binary(prob = 0.6, N),   mayor_approval = draw_ordered(     x = rnorm(N, mean = -1 + 2 * mayor_copartisan),     breaks = c(-1.5, -0.5, 0.5, 1.5),     break_labels = c(\"Strongly Disagree\", \"Disagree\", \"Neutral\",                      \"Agree\", \"Strongly Agree\")   ) )  table(respondent_data$mayor_approval, respondent_data$mayor_copartisan) mayor_approval <- draw_ordered(x = runif(n = 100, min = -2.5, max = 2.5),                                breaks = c(-1.5, -0.5, 0.5, 1.5),                                break_labels = c(\"Strongly Disagree\", \"Disagree\",                                                 \"Neutral\", \"Agree\",                                                 \"Strongly Agree\"))"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"likert-data","dir":"Articles","previous_headings":"","what":"Likert Data","title":"Common Social Science variables","text":"Many survey responses focus labeling agreement, support, quality evaluation, including example , called “Likert” data psychologist Rensis Likert. scales typically 4, 5, 7 point scales measure. fabricatr includes simple shortcut make Likert variables without needing fill breaks break_labels time. using draw_likert, users need specify x latent variable – assumed distributed breaks spaced 1 unit apart data centered 0 – type Likert like (number categories). example, examine data , 4-category Likert scale options “Strongly Agree”, “Agree”, “Disagree”, “Strongly Disagree”, neutral category.","code":"draw_likert(runif(n = 100), min = 0, max = 1, bins = 7)  table(mayor_approval)"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"categorical-data-e-g--demographic-measures","dir":"Articles","previous_headings":"","what":"Categorical data (e.g. demographic measures)","title":"Common Social Science variables","text":"Surveys often collect demographic information respondents, including age, gender, ethnicity. point guide, begun see might generate continuous numerical variable like age, traditional binary measures gender might specified. variables, like inclusive measures gender, ethnicity, (hair color, eye color, city residence, many possible variables interest) “ordered” sense. data often called “categorical” data – given person probability belong possible categories. Imagine researchers conducting survey Kenya. wish capture country’s four largest ethnic groups: Kikuyu, Luhya, Kalenjin, Luo, also interested capturing smaller Maasai group. respondents identified “”. preparing research, researchers must simulate ethnicity expected respondents, first gather proportions group, fabricatr makes easy generate data based specifications like using draw_categorical:","code":"##   Kikuyu    Luhya Kalenjin      Luo   Maasai    Other  ##    0.172    0.138    0.129    0.105    0.022    0.435 respondent_ethnicity <- draw_categorical(   prob = c(0.172, 0.138, 0.129, 0.105, 0.022, 0.435),   category_labels = c(\"Kikuyu\", \"Luhya\", \"Kalenjin\", \"Luo\", \"Maasai\", \"Other\"),   N = 100)  table(respondent_ethnicity)"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"data-with-fixed-minimum-and-maximum-values","dir":"Articles","previous_headings":"","what":"Data with fixed minimum and maximum values","title":"Common Social Science variables","text":"often useful generate data fixed minimum maximum values, unclear best . general approach advocate generate latent variable (described ) might fall outside minimum maximum values, truncating variable minimum maximum values. Consider experiment pre-post treatment design. series respondents asked views government efficacy, measured respondents scoring government 0 100. respondents given treatment intervention: example, information government service delivery, mechanism report government fraud waste. Finally, researchers ask respondents question government efficacy. Researchers might simulate experiment choosing population level Average Treatment Effect (example, assume moderate treatment effect 15 points), adding shock centered point treated unit’s pre-treatment outcome (addition adding noise control group). challenge data naturally truncated: individuals whose scores already quite high may now modeled post-treatment scores 100. fact, example, respondents pre-treatment scores 100! matters real-world data gathered later truncated, researchers power detect effects may compromised high density responses near cutoff. result, important researchers model truncation directly. simple using functionality provided R: pmin pmax. used truncate variables like , pmax takes two arguments: vector numeric variables, minimum value want truncate . Please note , counter-intuitively, pmax used truncate minimum value pmin used truncate maximum value. see design action : Let’s consider pre_outcome created: first, respondent assigned pre_treatment score mean 70 points standard deviation 15 points. Next, scores fed pmax, along argument 0. scores lower 0 bumped truncated 0. Finally, scores fed pmin, along argument 100. scores higher 100 bumped truncated 100. result variables display desired effect:","code":"set.seed(19861108)  efficacy_experiment <- fabricate(   N = 1000,   treatment = draw_binary(0.5, N),   pre_outcome = rnorm(N, mean = 70, sd = 15),   post_outcome = pre_outcome + rnorm(N,                                      mean = ifelse(treatment, 15, 0),                                      sd = 10) ) set.seed(19861108)  fixed_efficacy_experiment <- fabricate(   N = 1000,   treatment = draw_binary(0.5, N),   pre_outcome = pmin(     pmax(rnorm(N, mean = 70, sd = 15), 0),     100),   post_outcome = pmin(     pmax(pre_outcome + rnorm(N,                              mean = ifelse(treatment, 15, 0),                              sd = 10), 0),     100) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"count-outcomes-and-skewed-distributions","dir":"Articles","previous_headings":"","what":"Count outcomes and skewed distributions","title":"Common Social Science variables","text":"Researchers may interested “count” outcomes, describe count events interest fixed time period. example section, draw “Propaganda Conflict: Evidence Rwandan Genocide” (Yanagizawa-Drott 2014), article uses quasi-experimental design establish association broadcasts Radio Télévision Libre des Mille Collines local instances violence Rwandan Genocide. Substantively, paper’s conclusion higher density radio coverage associated greater local participation genocidal violence. version data, two variables interest: number violent incidents, density radio coverage. know priori variables must least 0, unsure maximum number might , know number violent incidents must “discrete” variable (case, whole number) radio coverage “continuous” (can take fractional values). First, model number violent incidents, make use fabricatr’s draw_count function, quite simple – needs two arguments: mean, describes mean count, N, describes many units need count data . Statistically, function generates “Poisson-distributed” count data. one typical distributions used count data. Second, model radio covarage, might believe radio coverage example skewed data; words, urban areas might extremely dense radio coverage, many rural areas might low radio coverage. , thus, need data distribution looks like :  R makes available fairly simple function generating sort data, rlnorm, generates log-normal data. Log-normal data one key distributions used model data skew like one hypothesize: example, income data population (relatively wealthy people substantially income relatively many working class people). rlnorm takes three arguments: n (number observations), meanlog (mean log-transformed data), sdlog (standard deviation log-transformed data). Replicating real data important inference draw modeling results depends “support” (range values observations take) “density” (many observations take value); extent real-world data likely dense regions data sparse others, important synthetic data well order recover inferences accurate future real-world inferences, particularly uncertainty inferences.  Observe uncertainty around predictions far wider right end support, relatively little data, left end support, data lives. Thinking choosing parameters meanlog sdlog somewhat mathematically complex skewed distributions depending use , might choose different parameters. Consult R’s documentation log-normal data running ?Lognormal. addition, may find useful investigate distributions commonly used purpose including ?Beta ?Gamma. present example generating income data roughly approximates current U.S. income distribution using rgamma function. parameters income function derived extracting quantiles current U.S. income distribution selecting gamma distribution parameters multipliers best fit data: addition helper functions provided fabricatr built-R distributions suitable generating skewed data, R packages like sn also include useful functions generating skewed data can incorporated fabricate calls.","code":"rtlme_model <- fabricate(   N = 1000,   radio_coverage = rlnorm(N, meanlog=0, sdlog=1),   violent_incident_count = draw_count(mean = 1.5 * radio_coverage, N = N) ) population_data <- fabricate(   N = 1000,   income = 20000 * rgamma(N, 1.4, 0.65) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/common_social.html","id":"whats-next","dir":"Articles","previous_headings":"","what":"What’s next?","title":"Common Social Science variables","text":"brings us end introductory tutorial common social science variables. next step, tutorial variable generation fabricatr – targeted slightly technical audience – contains examples kinds variables can easily create fabricatr. addition, tutorials creating time series variables, using variable creation packages fabricatr. Finally, interested learning structure data (example, generate multi-level, panel, cross-classified data), can consult tutorials building data fabricatr, panel cross-classified data **fabricatr*.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"panel-data-construction","dir":"Articles","previous_headings":"","what":"Panel Data Construction","title":"Panel and Cross-classified data","text":"Let’s begin visualizing example panel data, data several countries several years.  data arrangement somewhat complex traditional nested, hierarchical data. observation draws common pool countries years. words, year-specific variables attached Country ’s 1997 observation also attached Country B’s 1997 observation. steps generating panel fabricatr follows: Generate multiple non-nested data frames (Countries Years) Use cross_levels() function join non-nested data frames make panel. Optionally, add new variables levels resulting cross-classified data. (Observation-level variables)","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"generating-multiple-non-nested-levels-in-fabricatr","dir":"Articles","previous_headings":"Panel Data Construction","what":"Generating multiple, non-nested levels in fabricatr","title":"Panel and Cross-classified data","text":"First, need generate country year data. default, fabricatr fully nests subsequent levels first level call. , must explicitly . Note function call evaluate specified two non-nested data frames, yet told fabricatr . second (subsequent) non-nested levels contain nest = FALSE argument – otherwise, years interpreted level nested within countries. level track variables, possible add many features like levels.","code":"panels <- fabricate(   countries = add_level(N = 150, country_fe = runif(N, 1, 10)),   years = add_level(N = 25, year_shock = runif(N, 1, 10), nest = FALSE),   ... )"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"importing-non-nested-data-frames","dir":"Articles","previous_headings":"Panel Data Construction","what":"Importing non-nested data frames","title":"Panel and Cross-classified data","text":"also possible import multiple non-nested data frames; allow assemble pre-existing data sources however like. Recall first argument fabricate() call data wish import. previously seen possible import single data frame way, also possible import list data frames, staging use cross-classifying data. Data imported manner looks like : , fabricate() call incomplete – imported data wish cross-classify , yet learned merge data. specify merge data, fabricate() simply return recent data frame imported generated, unmodified.","code":"example_data <- fabricate(   list(data_frame_1, data_frame_2),   ... )"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"specifying-a-merge-function","dir":"Articles","previous_headings":"Panel Data Construction","what":"Specifying a merge function","title":"Panel and Cross-classified data","text":"Specifying merge function create panel simple. need tell fabricatr levels wish merge, assembled panel can generate new variables observation-level. using call cross_levels(): Note cross_levels() takes single required argument, form = join_using(...). join_using command tells fabricatr assemble data. case, telling join countries data frame years data frame, resulting country-year observations. Just like regular add_level() commands, can add new variables full access existing columns.","code":"panels <- fabricate(   countries = add_level(N = 150, country_fe = runif(N, 1, 10)),   years = add_level(N = 25, year_shock = runif(N, 1, 10), nest = FALSE),   obs = cross_levels(     by = join_using(countries, years),     new_variable = country_fe + year_shock + rnorm(N, 0, 2)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"cross-classified-or-correlated-data-joins","dir":"Articles","previous_headings":"","what":"Cross-Classified or Correlated Data Joins:","title":"Panel and Cross-classified data","text":"Another type data fabricatr excels enabling cross-classified data. cross-classified dataset, just like panel, observations draw combination multiple existing data sets. example vignette students. Students attend primary school secondary school. Unlike panel, every student attends every school; every combination schools exactly one student. Student outcomes depend primary secondary school education. Let’s begin visualizing data laid :  main steps involved generating cross-classified data follows: Generate multiple non-nested data frames (Primary Secondary Schools) Use link_levels() function join non-nested data frames particular variables, optionally specifying desired correlation outcome. Optionally, add new variables levels resulting cross-classified data. (Student-level characteristics) already learned generate multiple non-nested data frames; now example specify merge function cross-classified data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"specifying-a-merge-function-for-cross-classified-data-","dir":"Articles","previous_headings":"Cross-Classified or Correlated Data Joins:","what":"Specifying a merge function for cross-classified data.","title":"Panel and Cross-classified data","text":"One difference panel data cross-classified data need specify number observations create combining existing levels data. example, may 20 primary schools 15 secondary schools mid-sized city, several thousand students. Specifying easy providing N argument link_levels() call. juncture, assume relationship primary school student attends secondary school student attends. model generates primary schools secondary schools, quality variable associated (ps_quality primary schools, ss_quality secondary schools): see compared generating panel, change switch joining function link_levels() adding N argument. result , predictably, data frame containing 1500 observations, five columns: primary_schools (ID), ps_quality, secondary_schools (ID), ss_quality, students (ID).","code":"schools_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(N = 15, ss_quality = runif(N, 1, 10), nest = FALSE),   students = link_levels(N = 1500, by = join_using(primary_schools, secondary_schools)) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"adding-additional-variables","dir":"Articles","previous_headings":"Cross-Classified or Correlated Data Joins:","what":"Adding additional variables","title":"Panel and Cross-classified data","text":"shown , simple add variables new, cross-classified data: , student assigned standardized testing score, equal baseline, plus additive effect quality primary school, plus large additive effect quality secondary school, plus stochastic component. linear regression confirms resulting data approximately reflects data generating process: variables can added students level, indeed either component levels.","code":"schools_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(N = 15, ss_quality = runif(N, 1, 10), nest = FALSE),   students = link_levels(     N = 1500, by = join_using(primary_schools, secondary_schools),     SAT_score = 800 + 13 * ps_quality + 26 * ss_quality +       rnorm(N, 0, 50)   ) ) lm(SAT_score ~ ps_quality + ss_quality, data = schools_data)"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"correlations-after-merging","dir":"Articles","previous_headings":"Cross-Classified or Correlated Data Joins:","what":"Correlations after merging","title":"Panel and Cross-classified data","text":"variety R packages support functionality joining data various ways. However, key feature fabricatr possible generate correlated cross-classified data. , assumed primary school student attended relationship secondary school student attends. assumption reflect actual patterns social world. might, example, reasonably assume students assigned better primary schools later assigned better secondary schools – whether due economic geography area, selective admissions, causes. easy specify correlation outcomes using much syntax used : , changed structure join_using() function call. First, variables joining ps_quality ss_quality. fabricatr locates variables within data frames come . Second specify Spearman’s (rank) correlation coefficient, rho, induce correlation resulting data based join_using function. case, want correlation ps_quality ss_quality 0.5. Technical details implementation function contained , mean time important thing note rho can value -1 1, resulting correlation approximately equal rho. Note: technical details implementation, true correlation resulting data slightly attenuated (smaller magnitude) specified rho. general purpose correction compensate attenuation. can check resulting correlation : 0.48 noted specified correlation exists within variables join specified: variables either data source explicitly connected except joined variables. Correlation possible cross-classified data, panel data.","code":"corr_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(N = 15, ss_quality = runif(N, 1, 10), nest = FALSE),   students = link_levels(     N = 1500, by = join_using(ps_quality, ss_quality, rho = 0.5),     SAT_score = 800 + 13 * ps_quality + 26 * ss_quality +       rnorm(N, 0, 50)   ) ) cor(corr_data$ps_quality, corr_data$ss_quality)"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"joining-more-than-two-levels","dir":"Articles","previous_headings":"","what":"Joining more than two levels","title":"Panel and Cross-classified data","text":"functions specified work joining two levels. extend student example include, example, college quality. Nothing changes join syntax beyond addition third subsequent variable names: One potential source failure specifying invalid rho. specify rho makes correlation three variables impossible obtain, fabricate() call fail. common case occurring specifying negative rho three levels – general, negatively correlated B, B negatively correlated C, C negatively correlated. Instead specifying rho correlation coefficient, users can specify sigma correlation matrix make resulting correlations sophisticated. Consider following setup: sigma must specified symmetric square matrix diagonal 1s feasible correlation structure.","code":"three_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(N = 15, ss_quality = runif(N, 1, 10), nest = FALSE),   colleges = add_level(N = 50, c_quality = runif(N, 1, 10), nest = FALSE),   students = link_levels(     N = 1500,     by = join_using(       ps_quality, ss_quality, c_quality,       rho = 0.2     ),     earning_potential = 20000 + (2000 * ps_quality) +       (6000 * ss_quality) + (10000 * c_quality) +       rnorm(N, 0, 5000)   ) ) sigma <- matrix(   c(     1, 0.4, 0.2,     0.4, 1, 0.8,     0.2, 0.8, 1   ),   ncol = 3, nrow = 3 )  adv_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(N = 15, ss_quality = runif(N, 1, 10), nest = FALSE),   colleges = add_level(N = 50, c_quality = runif(N, 1, 10), nest = FALSE),   students = link_levels(     N = 1500,     by = join_using(       ps_quality, ss_quality, c_quality,       sigma = sigma     ),     earning_potential = 20000 + (2000 * ps_quality) +       (6000 * ss_quality) + (10000 * c_quality) +       rnorm(N, 0, 5000)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/cross_classified.html","id":"technical-appendix-implementation-of-correlated-joins-","dir":"Articles","previous_headings":"","what":"Technical appendix: Implementation of correlated joins.","title":"Panel and Cross-classified data","text":"implementation correlated join done via Gaussian copula. Mathematically, occurring follows: User specifies correlation structure. Draw multivariate standard normal data correlation structure. Transform standard normal data dimension quantiles standard normal cumulative distribution function. Take data source distribution empirical quantile equal quantiles step 3. ensures data joined Spearman’s (rank) correlation coefficient specified multivariate standard normal draw. Map data chosen back row source distribution join row chosen row source distributions, ensuring covariates put resulting merged data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/getting_started.html","id":"creating-common-variable-types","dir":"Articles","previous_headings":"","what":"1. Creating common variable types","title":"Getting started with fabricatr","text":"fabricatr allows quickly create variables mimic plan collect course observational experimental work. current version supports common variable types including assignment treatment, count data, ordinal data (including “Likert scale” data, popular surveys survey experiments), categorical data (popular modeling demographic characteristics). addition, support creation data fixed intra-cluster correlations, individual observations can modelled part groups regions. Imagine survey experiment voters across social groups. fabricatr, can model voters part social groups, characteristics like ideology income, opinions political issues. can assign voters treatment encouraging vote proposition, model results experiment: Let’s look small fraction data generated way: Modeling data like allows common analyses advance conducting experiment. data can also included pre-analysis plan add clarity experimental design contribute improving transparency replicability. fabricatr also allows import existing data modify easily, resample existing data new, simulated populations. ’d like read using fabricatr model variables plan collect experiment, see guide common social science variables, technical manual generating variables fabricatr, tutorials resampling data integrating data-generating packages fabricatr workflow..","code":"library(fabricatr)  voters <- fabricate(   N = 1000,   group_id = rep(1:10, 100),   ideology = draw_normal_icc(mean = 0, N = N, clusters = group_id, ICC = 0.7),   ideological_label = draw_ordered(     x = ideology,     break_labels = c(       \"Very Conservative\", \"Conservative\",       \"Liberal\", \"Very Liberal\"     )   ),   income = exp(rlnorm(n = N, meanlog = 2.4 - (ideology * 0.1), sdlog = 0.12)),   Q1_immigration = draw_likert(x = ideology, min = -5, max = 5, bins = 7),   Q2_defence = draw_likert(x = ideology + 0.5, min = -5, max = 5, bins = 7),   treatment = draw_binary(0.5, N = N),   proposition_vote = draw_binary(latent = ideology + 1.2 * treatment, link = \"probit\") )"},{"path":"https://declaredesign.org/r/fabricatr/articles/getting_started.html","id":"structuring-your-data","dir":"Articles","previous_headings":"","what":"2. Structuring your data","title":"Getting started with fabricatr","text":"fabricatr also allows structure data shape real experimental data . Although many experimental data individual observations, like example , popular data structures include panel data, multi-level (hierarchical “nested”) data cross-classified data. fabricatr supports cases. One common example social sciences panel data, easy create fabricatr: ’d like read using fabricatr structure data, see guides building importing datasets fabricatr, generating cross-classified panel data, resampling data fabricatr.","code":"library(fabricatr)  panel <- fabricate(   countries = add_level(N = 150, country_fe = runif(N, 1, 10)),   years = add_level(N = 25, year_shock = runif(N, 1, 10), nest = FALSE),   observations = cross_levels(     by = join_using(countries, years),     outcome_it = country_fe + year_shock + rnorm(N, 0, 2)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/getting_started.html","id":"declaredesign","dir":"Articles","previous_headings":"","what":"DeclareDesign","title":"Getting started with fabricatr","text":"fabricatr one four packages make DeclareDesign software suite. Along fabricatr, helps imagine data collect , offer estimatr, fast estimators social scientists, randomizr, easy use tools common forms random assignment sampling, DeclareDesign, package declaring diagnosing research designs understand improve . addition documentation R online, happy respond questions using packages, incorporate requests new features. can contact us via DeclareDesign help board.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"wakefield-simulating-common-demographic-features","dir":"Articles","previous_headings":"","what":"wakefield: simulating common demographic features","title":"Using other data generating packages with fabricatr","text":"wakefield (Tyler Rinker) popular R package creating synthetic data. wakefield’s strength can quickly generate common variables, especially human demographic features. wakefield can easily integrated fabricatr workflow one two ways: using wakefield create individual variables within fabricate call, using wakefield make data frame importing data frame fabricate call. example, create data-set participants survey experiment, using wakefield generate demographic variables Researchers interested learning wakefield’s available functionality, parameterizations, default probability can read wakefield’s user guide GitHub. addition creating variables within fabricate call, users can import completed wakefield data frames fabricate call:","code":"library(wakefield)  survey_experiment_df <- fabricate(   N = 50,   treatment = draw_binary(prob = 0.5, N = N),   age = age(n = N),   race = race(n = N),   sex = sex(n = N), ) survey_experiment_df <- r_data_frame(   n = 50,   age,   race,   sex)  fabricatr_df <- fabricate(   data = survey_experiment_df,   treatment = draw_binary(prob = 0.5, N = N) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"randomnames-plausible-names-for-human-subjects","dir":"Articles","previous_headings":"","what":"randomNames: Plausible names for human subjects","title":"Using other data generating packages with fabricatr","text":"randomNames (Damian Betebenner) package one thing well: generate random names human subjects (including specified genders ethnicities). primary use case use part generating variable within fabricate call. example, use fabricate generate demographic data, randomNames generate matching names. Note make use existing is_female variable fabricate call ensure randomNames generates gender-typical names.","code":"library(randomNames)  experiment_data <- fabricate(   N = 50,   treatment = draw_binary(prob = 0.5, N = N),   is_female = draw_binary(prob = 0.5, N = N),   patient_name = randomNames(N, gender=is_female) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"modeling-causality-with-dags-and-simcausal","dir":"Articles","previous_headings":"","what":"Modeling causality with DAGs and simcausal","title":"Using other data generating packages with fabricatr","text":"Users familiar DAGS (directed acyclic graphs) model causal inference may interest using simcausal package, allows users specify DAGS model sample . Integrating package fabricatr likely involve using simcausal first specify model, simulating data model, importing data fabricate call user fabricatr. Consider example, common literature educational attainment school outcomes, students come families wealth parameter, assignment schools based partially wealth, test outcomes (testoutcome) based school quality wealth.","code":"library(\"simcausal\")  # Define DAG D <- DAG.empty() +    node(\"wealth\", distr = \"rnorm\",        mean = 30000,        sd = 10000) +   node(\"schoolquality\", distr = \"runif\",        min = 0 + (5 * (wealth > 50000)),        max = 10) +   node(\"testoutcome\", distr = \"runif\",        min = 0 + 0.0001 * wealth + 0.25 * schoolquality,        max = 10)  # Freeze DAG object set_dag <- set.DAG(D)  # Draw data from DAG df <- sim(set_dag, n = 100)  # Pass into fabricate call and make new variables as necessary fabricate(df,           passed_test = testoutcome > 6,           eligible_for_snap = wealth < 25000)"},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"survival-and-duration-models-with-simsurv","dir":"Articles","previous_headings":"","what":"Survival and duration models with simsurv","title":"Using other data generating packages with fabricatr","text":"simsurv package dedicated generating panel survival data. likely way might integrate simsurv fabricatr use fabricatr generating covariates can imported simsurv model hazard duration context. , example clinical trial cancer drug. Participants expected biographical data: age, gender, whether patient smokes, disease stage, assignment treatment, KPS score (commonly used evaluate overall patient health). Survival data creates ragged longitudinal survey; patients die course trial, removing observations. Others continue alive end trial. specify “hazard function”, tells simsurv course patient survival change time. Covariates positive betas increase risk death, covariates negative betas decrease risk death. track patients 5 years treatment. generated data survival_data object can re-imported participant_data using data merging tools, including fabricate call, used subsequent analyses (e.g. using survival package).","code":"library(simsurv)  # Simulate patient data in a clinical trial participant_data <- fabricate(   N = 100,   age = runif(N, min = 18, max = 85),   is_female = draw_binary(prob = 0.5, N = N),   is_smoker = draw_binary(prob = 0.2 + 0.2 * (age > 50), N = N),   disease_stage = round(runif(N, min = 1 + 0.5 * (age > 65), max = 4)),   treatment = draw_binary(prob = 0.5, N = N),   kps = runif(N, min = 40, max = 100) )  # Simulate data in the survival context survival_data <- simsurv(   lambdas = 0.1, gammas = 0.5,   x = participant_data,    betas = c(is_female = -0.2, is_smoker = 1.2,             treatment = -0.4, kps = -0.005,             disease_stage = 0.2),   maxt = 5)"},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"time-series-using-forecast","dir":"Articles","previous_headings":"","what":"Time series using forecast","title":"Using other data generating packages with fabricatr","text":"forecast, Rob Hyndman, package commonly used analyze time series data also functionality capable generating simulated time series data. forecast can use Arima simulate functions create pre-specified ARIMA models, including seasonal time trends. , provide example using forecast generate ARIMA time series, reshape data, import fabricatr create new variables interest. , ts converts series data time series, frequency specifying number observations per unit time (case, example, quarters year). Arima ingests data fits ARIMA model specified parameters. simulate draws new data fit time series, producing vector interest. import data fabricate call (converting data frame) add new columns interest.","code":"library(forecast)  arima_model <- simulate(   Arima(ts(rnorm(100), frequency = 4),         order = c(1, 0, 1))    fabricate(data.frame(arima_model),            year = rep(1:25, each=4),           quarter = rep(1:4, 25))"},{"path":"https://declaredesign.org/r/fabricatr/articles/other_packages.html","id":"other-data-simulation-tools","dir":"Articles","previous_headings":"","what":"Other data simulation tools","title":"Using other data generating packages with fabricatr","text":"R ecosystem many data simulation tools, can used complement supplement fabricatr workflow. packages noticed covered include: gems Luisa Salazar Vizcaya simFrame Andreas Alfons simPop Matthias Templ simstudy Keith Goldfeld synthPop Beata Nowok SimCorrMix Allison Cynthia Fialkowski ’d like see tutorial using packages others fabricatr, please Contact Us can help ","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/resampling.html","id":"bootstrapping","dir":"Articles","previous_headings":"","what":"Bootstrapping","title":"Resampling data with fabricatr","text":"simplest option fabricatr “bootstrap” data. Taking data N observations, “bootstrap” resamples observations replacement generates N new observations. Existing observations may used zero times, , . Bootstrapping simple resample_data() function: also possible resample fewer greater number observations existing data. can specifying argument N resample_data(). Consider expanding small dataset allow better imagination larger data collected later. 100","code":"survey_data <- fabricate(N = 10, voted_republican = draw_binary(prob = 0.5, N = N))  survey_data_new <- resample_data(survey_data) head(survey_data_new) large_survey_data <- resample_data(survey_data, N = 100) nrow(large_survey_data)"},{"path":"https://declaredesign.org/r/fabricatr/articles/resampling.html","id":"resampling-hierarchical-data","dir":"Articles","previous_headings":"","what":"Resampling hierarchical data","title":"Resampling data with fabricatr","text":"One powerful features fabricatr ability resample hierarchical data levels. requires specifying levels want resample ID_labels argument. Unless otherwise specified, units levels resampled level kept. earlier country-province-citizen dataset, resampling countries lead provinces citizens selected country carried forward. can resample multiple levels simultaneously. Consider example, takes dataset containing 2 cities 3 citizens, resamples dataset 3 cities, containing 5 citizens. resample_data() first select cities resampled. , city, continue selecting citizens resampled. higher level unit used (example, city chosen twice), lower level subsequently resampled, choices units keep lower level differ copy higher level. example, city 1 chosen twice, sets five citizens chosen copy city 1 differ. can also specify levels wish resample using name arguents N parameter, like example exactly thing previous example, specifies level names different way:","code":"my_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = 3, age = runif(N, 18, 70))   )  my_data_2 <- resample_data(my_data, N = c(3, 5), ID_labels = c(\"cities\", \"citizens\")) head(my_data_2) my_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = 3, age = runif(N, 18, 70))   )  my_data_2 <- resample_data(my_data, N = c(cities = 3, citizens = 5)) head(my_data_2)"},{"path":"https://declaredesign.org/r/fabricatr/articles/resampling.html","id":"unique-per-sample-labels","dir":"Articles","previous_headings":"","what":"Unique per-sample labels","title":"Resampling data with fabricatr","text":"researchers may interested preserving unique labels sample draw given level. example may sample cities, , want run city-level statistics; city sampled twice, city-level statistic incorrectly combine samples. can solved unique_labels = TRUE, create new column sampled level, called <level name>_unique, unique sample. Consider following code:","code":"my_data_unique <- resample_data(my_data, N = c(cities = 3), unique_labels = TRUE)"},{"path":"https://declaredesign.org/r/fabricatr/articles/resampling.html","id":"passthrough-resampling","dir":"Articles","previous_headings":"","what":"“Passthrough” Resampling","title":"Resampling data with fabricatr","text":"cases may make sense resample unit given level. example, may value resampling 1 citizen every city represented data set. fabricatr allows user specify N argument given level accomplish :","code":"my_data <-   fabricate(     cities = add_level(N = 2, elevation = runif(n = N, min = 1000, max = 2000)),     citizens = add_level(N = 3, age = runif(N, 18, 70))   )  my_data_3 <- resample_data(my_data, N = c(ALL, 1), ID_labels = c(\"cities\", \"citizens\")) head(my_data_3)"},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"single-unit-fixed-time-trend-data","dir":"Articles","previous_headings":"","what":"Single unit fixed time trend data","title":"Time series data with fabricatr","text":"simplest possible example involves single unit specified, time-dependent data, linear trend. example generate geographic location fixed linear time trend GDP growth. First, begin creating tracking progress time trend, ts_year, begins 0 increases one across observations. Next, create variable depends current value ts_year; GDP measure unit begins 20 (log units) increases one third log unit year. also specify stochastic error term.","code":"panel_unit <- fabricate(   N = 20,   ts_year = 0:19,   gdp_measure = 20 + 0.3 * ts_year + rnorm(N, sd=0.3) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"multiple-units-with-time-trends","dir":"Articles","previous_headings":"","what":"Multiple units with time trends","title":"Time series data with fabricatr","text":"complex example might involve several geographic units, separate growth value. can use fabricatr’s support multi-level, hierarchical data elaborate: , country-year inherits parameters country: base GDP, annual growth rate (constant model), error parameter. resulting data 25 rows; 5 years 5 countries.","code":"panel_units <- fabricate(   countries = add_level(     N = 5,     base_gdp = runif(N, 15, 22),     growth_units = runif(N, 0.2, 0.8),     growth_error = runif(N, 0.1, 0.5)   ),   years = add_level(     N = 5,     ts_year = 0:4,     gdp_measure = base_gdp + (ts_year * growth_units) + rnorm(N, sd=growth_error)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"multiple-units-with-fixed-global-time-trends","dir":"Articles","previous_headings":"Multiple units with time trends","what":"Multiple units with fixed global time trends","title":"Time series data with fabricatr","text":"Note also possible include fixed global trend example including part variable specification:","code":"global_trend <- 0.1  global_trend_example <- fabricate(   countries = add_level(     N = 5,     base_gdp = runif(N, 15, 22),     growth_units = runif(N, 0.2, 0.8),     growth_error = runif(N, 0.1, 0.5)   ),   years = add_level(     N = 5,     ts_year = 0:4,     gdp_measure = base_gdp +       (ts_year * global_trend) + (ts_year * growth_units) +       rnorm(N, sd=growth_error)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"multiple-units-with-global-yearly-shocks","dir":"Articles","previous_headings":"","what":"Multiple units with global yearly shocks","title":"Time series data with fabricatr","text":"Even complex designs may include non-trend global level shocks (example, financial crises booms affect countries). traditional hierarchical data design may fit , want common country-level data common year-level data, combined form country-year observations. good example data can best described multiple non-nested levels. Users interested implementing review manual cross-classified panel data. example use cross_levels non-nested level data. Notice variable specified appropriate level; time series year indicators yearly shocks specified year level; country-specific time trend information base GDP specified country level; actual GDP measure, country-year, specified country-year level.","code":"panel_global_data <- fabricate(   years = add_level(     N = 5,     ts_year = 0:4,     year_shock = rnorm(N, 0, 0.3)   ),   countries = add_level(     N = 5,     base_gdp = runif(N, 15, 22),     growth_units = runif(N, 0.2, 0.5),     growth_error = runif(N, 0.1, 0.5),     nest = FALSE   ),   country_years = cross_levels(     by = join_using(years, countries),     gdp_measure = base_gdp + year_shock + (ts_year * growth_units) +       rnorm(N, sd=growth_error)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"seasonal-or-arima-time-series","dir":"Articles","previous_headings":"","what":"Seasonal or ARIMA Time Series","title":"Time series data with fabricatr","text":"Although fabricatr formal functionality creation ARIMA time series, recommend interested users see guide using data creation packages fabricatr, includes example using forecast package generate ARIMA data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/time_series.html","id":"whats-next","dir":"Articles","previous_headings":"","what":"What’s next?","title":"Time series data with fabricatr","text":"may also interested online tutorial structuring panel cross-classified data..","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"fabricating-discrete-random-variables-","dir":"Articles","previous_headings":"","what":"Fabricating discrete random variables.","title":"Generating discrete random variables with fabricatr","text":"fabricatr provides convenient helper functions generate discrete random variables far easily using R’s built-data generation mechanisms. introduce types data can generate using fabricatr.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"binary-and-binomial-outcomes","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Binary and binomial outcomes","title":"Generating discrete random variables with fabricatr","text":"simplest possible type data binary random variable (also called bernoulli random variable). Generating binary random variable requires one parameter prob specifies probability outcomes drawn variable equal 1. default, draw_binary() generate N = length(prob) draws. N can also specified explicitly. Consider examples: addition binary variables, can make data repeated Bernoulli trials (“binomial” data). requires using draw_binomial() function specifying argument trials, equal number trials. researchers may interested specifying probabilities “link function”. can done data generating functions link argument. default link function “identity”, also support “logit”, “probit”. link functions transform continuous unbounded latent data probabilities positive outcome. specifying link function, also specify latent variable latent argument.","code":"draw_binary_ex <- fabricate(   N = 3, p = c(0, .5, 1),   binary_1 = draw_binary(prob = p),   binary_2 = draw_binary(N = 3, prob = 0.5) ) binomial_ex <- fabricate(   N = 3,   freethrows = draw_binomial(N = N, prob = 0.5, trials = 10) ) bernoulli_probit <- fabricate(   N = 3, x = 10 * rnorm(N),   binary = draw_binary(latent = x, link = \"probit\") )"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"ordered-outcomes","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Ordered outcomes","title":"Generating discrete random variables with fabricatr","text":"researchers may interested generating ordered outcomes – example, Likert scale outcomes. can draw_ordered() function. Ordered variables require vector breakpoints, supplied argument breaks – points underlying latent variable switches category category. first break always lower bound data, final break always upper bound data – breaks cover data, draw_ordered() attempt correct adding breaks appropriate. following example, three observations latent variable x continuous unbounded. variable ordered transforms x three numeric categories: 1, 2, 3. values x -1 result ordered 1; values x -1 1 result ordered 2; values x 1 result ordered 3:","code":"ordered_example <- fabricate(   N = 3,   x = 5 * rnorm(N),   ordered = draw_ordered(x, breaks = c(-Inf, -1, 1, Inf)) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"likert-variables","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Likert variables","title":"Generating discrete random variables with fabricatr","text":"Likert variables special case ordered variables. Users can use draw_ordered() properly specified breaks break labels generate Likert data, use draw_likert() function convenient alias: draw_likert() takes one compulsory argument (x, represents latent variable transformed ordered data). default, draw_likert() provides 7-item Likert scale breaks [-\\(\\infty\\), -2.5, -1.5, -0.5, 0.5, 1.5, 2.5, \\(\\infty\\)]. Users can explicitly specify type argument use types Likert data. Supported types 4, 5, 7. Default breaks 5-item Likert scales [-\\(\\infty\\), -1.5, -0.5, 0.5, 1.5, \\(\\infty\\)]. Default breaks 4-item Likert scales [-\\(\\infty\\), -1, 0, 1, \\(\\infty\\)]. Optionally, users can specify breaks. override type command scale type detected based length break argument. , break argument 8 values produce 7-item Likert scale, one 6 values produce 5-item Likert scale, one 5 values produce 4-item Likert scale. Labels automatically provided draw_likert(). default 7-item Likert scale uses labels [“Strongly Disagree”, “Disagree”, “Lean Disagree”, “Don’t Know / Neutral”, “Lean Agree”, “Agree”, “Strongly Agree”]. Examples users might use function available : function convenient, quick alias creating likert variables labels. Users want flexibility respect break labels number breaks use draw_ordered() specify breaks break labels explicitly.","code":"survey_data <- fabricate(   N = 100,   Q1 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 7),   Q2 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 7),   Q3 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 7) ) survey_data <- fabricate(   N = 100,   Q1 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 7),   Q2 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 5),   Q3 = draw_likert(x = rnorm(N), min = -5, max = 5, bins = 4),   Q4 = draw_likert(x = rnorm(N), breaks = c(-Inf, -0.8, 0, 1, 2, Inf)) )  table(survey_data$Q2)"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"ordered-quantile-outcomes-e-g--quartile-decile-etc-","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Ordered quantile outcomes (e.g. quartile, decile, etc.)","title":"Generating discrete random variables with fabricatr","text":"variables interest modeled quantile outcomes; example, income data survey might reported analyzed income deciles. provide two simple helper functions purpose: draw_quantile() allows generate quantile outcomes without underlying data, split_quantile() allows transform underlying data quantile outcomes. particularly relevant survey data made granular protect respondent privacy. example, generate income data population transform deciles: type paramater split_quantile() function specifies many bins split data . decile example, 10. Note resulting quantiles based sample data, parameterization population. also possible skip step characterizing income data directly modeling income deciles: parameterization income variable derived researching U.S. individual income data using numerical optimization derive parameterization best approximated series quantiles data. Many data generation packages, including wakefield, implement automatic generation income data. information using fabricatr data generating packages, see online tutorial","code":"population <- fabricate(   N = 1000,   income = 20000 * rgamma(N, 1.4, 0.65),   income_decile = split_quantile(income, type = 10) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"count-outcomes","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Count outcomes","title":"Generating discrete random variables with fabricatr","text":"draw_count() allows create Poisson-distributed count outcomes. require user specify parameter mean, equal Poisson distribution mean (often referred lambda statistical formulations count data).","code":"count_outcome_example = fabricate(N = 3,                                   x = c(0, 5, 100),                                   count = draw_count(mean = x))"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"categorical-data","dir":"Articles","previous_headings":"Fabricating discrete random variables.","what":"Categorical data","title":"Generating discrete random variables with fabricatr","text":"draw_categorical() can generate non-ordered, categorical data. Users must provide vector probabilities category (matrix, observation separate probabilities). probabilities sum exactly one, normalized, negative probabilities cause error. first example, unit different set probabilities probabilities provided matrix: second example, unit probability getting given category. draw_categorical() issue warning remind interpreting vector way. “categorical” variables can also use link functions, example generate multinomial probit data.","code":"categorical_example <- fabricate(   N = 6,   p1 = runif(N, 0, 1),   p2 = runif(N, 0, 1),   p3 = runif(N, 0, 1),   cat = draw_categorical(N = N, prob = cbind(p1, p2, p3)) ) warn_draw_cat_example <- fabricate(   N = 6,   cat = draw_categorical(N = N, prob = c(0.2, 0.4, 0.4)) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"correlated-random-variables","dir":"Articles","previous_headings":"","what":"Correlated random variables","title":"Generating discrete random variables with fabricatr","text":"functionality EXPERIMENTAL, guarantee properties data structures. sure diagnose design assess distributions variables. fabricatr makes easy generate correlated random variables one time. need reference variable, desired rank correlation coefficient (-1 1), draw_ function specify target distribution correlated variable. done using function called correlate(), takes four distinct arguments: draw_handler, un-quoted name desired outcome distribution (e.g. draw_binary, draw_binomial, draw_count); parameters needed distribution (e.g. mean draw_count); given, reference variable new variable correlated , rho, rank correlation coefficient targeting. example, generate individuals, given battery public opinion questions. responses aggregated index scores several categories: conservative values, economic conservatism, foreign policy interventionism. Unpacking example; first, respondents asked 20 questions 40% chance answering yes question. result summed index. Next, respondents asked 20 questions 60% chance answering yes question, result also constrained rank-correlated rho = 0.5 score conservative_values index. Finally, 20 questions asked respondents foreign policy, 40% chance answering yes, index score somewhat weakly correlated conservative_values. argument N necessary resulting distribution automatically detected variable specified given. can analyze data verify , subject limitations random sampling, results reflect specification. First, let’s verify means approximately 0.4, 0.6, 0.4: Next, let’s check correlation variables interest: also possible use correlate() variable generation functions, base R even custom functions. Custom functions must take argument quantile_y, vector supplies quantiles distribution draw . Base R functions supported described : Please observe first argument correlate, draw_handler, must supplied unquoted name variable generating function. default, function works base R distributions; information using third party custom data generating function, see advanced features tutorial note correlated data: Although method used generate data correlated average rank correlation rho, variance normal, distributions less flexibility less likely achieve target correlation. example, first variable normally distributed wide range values, target variable binary 0/1 variable, correlation imprecise lack flexibility target variable.","code":"respondents <- fabricate(   N = 100,   conservative_values = draw_binomial(prob = 0.4, trials = 20, N = N),   economic_conservative = correlate(given = conservative_values,                                     rho = 0.5,                                     draw_binomial,                                     prob = 0.6,                                     trials = 20),   foreign_policy = correlate(given = conservative_values,                              rho = 0.3,                              draw_binomial,                              prob = 0.4,                              trials = 20) ) apply(respondents[2:4], 2, mean) / 20 cor(respondents[, 2:4], method=\"spearman\")[1, ] student_report_card <- fabricate(   N = 100,   math_score = rnorm(N, mean = 80, sd = 5),   chemistry_score = correlate(given = math_score, rho = 0.8,                               rnorm, mean = 75, sd = 5),   civics_score = correlate(given = math_score, rho = 0.6,                            rnorm, mean = 85, sd = 5) )"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"fabricating-cluster-correlated-random-variables-icc-","dir":"Articles","previous_headings":"","what":"Fabricating cluster-correlated random variables (ICC).","title":"Generating discrete random variables with fabricatr","text":"also provide helper functions generate cluster-correlated random variables fixed intra-cluster correlation (ICC) values. two functions draw_binary_icc() draw_normal_icc() allow generate discrete binary data fixed ICCs normal data fixed ICCs.","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"binary-data-with-fixed-iccs","dir":"Articles","previous_headings":"Fabricating cluster-correlated random variables (ICC).","what":"Binary data with fixed ICCs","title":"Generating discrete random variables with fabricatr","text":"draw_binary_icc() takes three required arguments: prob, probability vector probabilities determine chance given observation 1; clusters, map units clusters (required generate correlation structure); ICC, fixed intra-cluster correlation (0 1). Users may optionally specify N; specified, draw_binary_icc() determine based length clusters vector. Consider following example, models whether individuals smoke: see approximately 20% population smokes, line specification, patterns heterogeneity see cluster? learn 5 clusters, 4 overwhelmingly non-smokers, fifth composed 80% smokers. can also specify separate mean cluster; worth noting higher ICC, cluster mean depart nominal cluster mean. specify vector probabilities correlation coefficient, default values probability 0.5 cluster ICC 0.5. specify cluster IDs, function return error.","code":"# 100 individual population, 20 each in each of 5 clusters clusters = rep(1:5, 20)  # Individuals have a 20% chance of smoking, but clusters are highly correlated # in their tendency to smoke smoker = draw_binary_icc(prob = 0.2, clusters = clusters, ICC = 0.5)  # Observe distribution of smokers and non-smokers table(smoker) table(clusters, smoker)"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"normal-data-with-fixed-iccs","dir":"Articles","previous_headings":"Fabricating cluster-correlated random variables (ICC).","what":"Normal data with fixed ICCs","title":"Generating discrete random variables with fabricatr","text":"draw_normal_icc() takes four required arguments: mean, mean vector means, one cluster; clusters, map units clusters (required generate correlation structure); ICC, fixed intra-cluster correlation coefficient; sd, standard deviation vector standard deviations, one cluster. Users can optionally specify N, number units, supplied draw_normal_icc() determine based length clusters vector. sd supplied, cluster assumed within-cluster standard deviation 1 sd_between implied sd ICC parameter. mean supplied, cluster assumed mean zero. , model student academic performance cluster: 84.12 mean grade matches population mean. Now let’s look relationship cluster letter grade observe cluster pattern: obvious upon inspection two clusters contain academic high-performers, two clusters substantial failure rate. Although cluster mean expectation, induced intra-cluster correlation forces clusters higher others lower. Alternatively, users can specify ICC total_sd. resulting variable rescaled standard deviation exactly equal total_sd.","code":"# 100 students, 10 each in 10 clusters clusters <- rep(1:5, 20)  numeric_grade <- draw_normal_icc(mean = 80, clusters = clusters, ICC = 0.5, sd = 15)  letter_grade <- draw_ordered(   x = numeric_grade,   breaks = c(-Inf, 60, 70, 80, 90, Inf),   break_labels = c(\"F\", \"D\", \"C\", \"B\", \"A\") )  mean(numeric_grade) table(letter_grade, clusters)"},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Generating discrete random variables with fabricatr","text":"interested reading generate specific variables fabricatr, can read tutorial common social science variables, learn use data-generating packages fabricatr. interested learning import build data, can read introduction building importing data. advanced users can read tutorial generating panel cross-classified data. can also learn bootstrapping resampling hierarchical data.","code":""},{"path":[]},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"correlated-data","dir":"Articles","previous_headings":"Technical Appendix","what":"Correlated Data","title":"Generating discrete random variables with fabricatr","text":"generating correlated data using correlate(), following approach used, X source variable, F empirical distribution X, G target distribution, Y realized variable drawn distribution: Calculate quantiles observed X empirical distribution X Draw quantiles standard normal distribution Generate standard normal version Y based specified relationship. Map standard normal Y quantiles standard normal distribution Draw target distribution quantiles. transformations affine, rank order correlation induced standard normal stage preserved target distribution. Mathematically: \\[ \\begin{aligned}   X_{quan} &= F^{-1}(X) \\\\   X_{std} &= \\Phi(X_{quan}) \\\\   Y_{std} &\\sim N(\\rho \\times X_{std}, (1 - \\rho^2)) \\\\   Y_{quan} &= \\Phi^{-1}(Y_{std}) \\\\   Y &= G(Y_{quan}) \\end{aligned} \\] One thing may counterintuitive approach correlation based sample characteristics X – empirical data X observed without reference distribution origin – population characteristics Y. choice chosen minimizes amount information required users maximizes flexibility source variables, although may result imprecision given draw owing finite sample size X (chance deviation X desired distribution sampling).","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"binary-icc","dir":"Articles","previous_headings":"Technical Appendix","what":"Binary ICC","title":"Generating discrete random variables with fabricatr","text":"generating binary data fixed ICC, use formula, \\(\\) cluster \\(j\\) unit cluster: \\[ \\begin{aligned}   z_i &\\sim \\text{Bern}(p_i) \\\\   u_{ij} &\\sim \\text{Bern}(\\sqrt{\\rho}) \\\\   x_{ij} &=   \\begin{cases}     x_{ij} \\sim \\text{Bern}(p_i) & \\quad \\text{} u_{ij} = 1 \\\\     z_i & \\quad \\text{} u_{ij} = 0   \\end{cases} \\end{aligned} \\] expectation, guarantees intra-cluster correlation \\(\\rho\\) cluster proportion \\(p_i\\). approach derived Hossain, Akhtar Chakraborti, Hrishikesh. “ICCBin: Facilitates Clustered Binary Data Generation, Estimation Intracluster Correlation Coefficient (ICC) Binary Data”, available CRAN GitHub","code":""},{"path":"https://declaredesign.org/r/fabricatr/articles/variable_generation.html","id":"normal-icc","dir":"Articles","previous_headings":"Technical Appendix","what":"Normal ICC","title":"Generating discrete random variables with fabricatr","text":"generating normal data fixed ICC, follow formula, \\(\\) cluster \\(j\\) unit cluster: \\[ \\begin{aligned}   \\sigma^2_{\\alpha } &= \\frac{(\\rho * \\sigma^2_{\\epsilon })}{(1 - \\rho)} \\\\   \\alpha_i &\\sim \\mathcal{N}(0, \\sigma^2_{\\alpha }) \\\\   \\mu_{ij} &\\sim \\mathcal{N}(\\mu_i, \\sigma^2_{\\epsilon }) \\\\   x_{ij} &= \\mu_{ij} + \\alpha_i \\end{aligned} \\] expectation, approach guarantees intra-cluster correlation \\(\\rho\\), cluster mean \\(\\mu_{}\\), cluster-level variance error terms \\(\\sigma^2_{\\epsilon }\\). approach specified StatsExchange.","code":""},{"path":"https://declaredesign.org/r/fabricatr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Graeme Blair. Author, maintainer. Jasper Cooper. Author. Alexander Coppock. Author. Macartan Humphreys. Author. Aaron Rudkin. Author. Neal Fultz. Author. David C. Hall. Contributor.","code":""},{"path":"https://declaredesign.org/r/fabricatr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Blair G, Cooper J, Coppock , Humphreys M, Rudkin , Fultz N (2023). fabricatr: Imagine Data Collect . https://declaredesign.org/r/fabricatr/, https://github.com/DeclareDesign/fabricatr.","code":"@Manual{,   title = {fabricatr: Imagine Your Data Before You Collect It},   author = {Graeme Blair and Jasper Cooper and Alexander Coppock and Macartan Humphreys and Aaron Rudkin and Neal Fultz},   year = {2023},   note = {https://declaredesign.org/r/fabricatr/, https://github.com/DeclareDesign/fabricatr}, }"},{"path":"https://declaredesign.org/r/fabricatr/index.html","id":"fabricatr-imagine-your-data-before-you-collect-it","dir":"","previous_headings":"","what":"Imagine Your Data Before You Collect It ","title":"Imagine Your Data Before You Collect It ","text":"Making decisions research design analysis strategies often difficult data collected, hard imagine exact form data take. Instead, researchers typically modify analysis strategies fit data. fabricatr helps researchers imagine data look like collect . Researchers can evaluate alternative analysis strategies, find best one given data look, precommit looking realized data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/index.html","id":"installing-fabricatr","dir":"","previous_headings":"","what":"Installing fabricatr","title":"Imagine Your Data Before You Collect It ","text":"install latest stable release fabricatr, please ensure running version 3.5 later R run following code:","code":"install.packages(\"fabricatr\")"},{"path":"https://declaredesign.org/r/fabricatr/index.html","id":"getting-started","dir":"","previous_headings":"","what":"Getting started","title":"Imagine Your Data Before You Collect It ","text":"installed fabricatr, can easily import data generate new data. fabricatr designed help solve two key problems: Generating variables look like real thing, including Likert survey responses, treatment status, demographic variables, variables correlated group. Generating data structured like real thing, including panel data, multi-level (“nested”) data cross-classified data. fabricatr easy learn easy read. Consider example generates data modeling United States House Representatives:","code":"library(fabricatr)  house_members <- fabricate(   party_id = add_level(     N = 2, party_names = c(\"Republican\", \"Democrat\"), party_ideology = c(0.5, -0.5),     in_power = c(1, 0), party_incumbents = c(241, 194)   ),   rep_id = add_level(     N = party_incumbents, member_ideology = rnorm(N, party_ideology, sd = 0.5),     terms_served = draw_count(N = N, mean = 4),     female = draw_binary(N = N, prob = 0.198)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/index.html","id":"next-steps","dir":"","previous_headings":"","what":"Next Steps","title":"Imagine Your Data Before You Collect It ","text":"information, read online tutorial get started fabricatr. tutorial give brief overview fabricatr’s main functions direct towards next steps. can also read documentation inside R using command ?fabricate entry point. project generously supported grant Laura John Arnold Foundation seed funding EGAP.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/ALL.html","id":null,"dir":"Reference","previous_headings":"","what":"Magic number constant to allow users to specify ALL for passthrough\nresampling — ALL","title":"Magic number constant to allow users to specify ALL for passthrough\nresampling — ALL","text":"Magic number constant allow users specify passthrough resampling","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/ALL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magic number constant to allow users to specify ALL for passthrough\nresampling — ALL","text":"","code":"ALL"},{"path":"https://declaredesign.org/r/fabricatr/reference/ALL.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Magic number constant to allow users to specify ALL for passthrough\nresampling — ALL","text":"object class integer length 1.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/correlate.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform generation of a correlated random variable. — correlate","title":"Perform generation of a correlated random variable. — correlate","text":"function EXPERIMENTAL, guarantee properties data structures. sure diagnose design assess distribution variables.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/correlate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform generation of a correlated random variable. — correlate","text":"","code":"correlate(draw_handler, ..., given, rho)"},{"path":"https://declaredesign.org/r/fabricatr/reference/correlate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform generation of a correlated random variable. — correlate","text":"draw_handler unquoted name function generate data. Currently, draw_binary, draw_binomial, draw_count supported. ... arguments draw_handler (e.g. prob, mean, etc.) given vector can ordered; reference distribution X Y correlated . rho rank correlation coefficient -1 1.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/correlate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform generation of a correlated random variable. — correlate","text":"order generate random variable specific distribution based another variable distribution correlation coefficient rho, map first, known variable standard normal space via affine transformation, generate conditional distribution resulting variable standard normal, map standard normal back target distribution. result ensure, expectation, rank-order correlation rho.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/correlate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform generation of a correlated random variable. — correlate","text":"","code":"# Generate a variable of interest exam_score <- pmin(100, rnorm(n = 100, mean = 80, sd = 10))  # Generate a correlated variable using fabricatr variable generation scholarship_offers <- correlate(given = exam_score, rho = 0.7,                                 draw_count, mean = 3)  # Generate a correlated variable using base R distributions final_grade <- pmax(100, correlate(given = exam_score, rho = 0.7,                                    rnorm, mean = 80, sd = 10))"},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates panel or cross-classified data — cross_levels","title":"Creates panel or cross-classified data — cross_levels","text":"function allows user create data structures paneled cross-classified: one level observation draws simultaneously two many source levels. Common examples panels include country-year data country-level year-level characteristics.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates panel or cross-classified data — cross_levels","text":"","code":"cross_levels(by = NULL, ...)  link_levels(N = NULL, by = NULL, ...)"},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates panel or cross-classified data — cross_levels","text":"result call join_using() specifies cross-classified data created ... variable series variables add resulting data frame cross-classified data created. N number observations resulting data frame. N NULL provided, join_using \"outer product\" -- merging row provided data frame data frame make full panel.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates panel or cross-classified data — cross_levels","text":"data.frame","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Creates panel or cross-classified data — cross_levels","text":"specifying appropriate arguments join_using() within function call, possible induce correlation cross-classified data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/cross_levels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Creates panel or cross-classified data — cross_levels","text":"","code":"# Generate full panel data panel <- fabricate(  countries = add_level(N = 20, country_shock = runif(N, 1, 10)),  years = add_level(N = 20, year_shock = runif(N, 1, 10), nest=FALSE),  obs = cross_levels(by = join_using(countries, years), GDP_it = country_shock + year_shock) )  # Include an \"N\" argument to allow for cross-classified # data. students <- fabricate(  primary_school = add_level(N = 20, ps_quality = runif(N, 1, 10)),  secondary_school = add_level(N = 15, ss_quality = runif(N, 1, 10), nest=FALSE),  students = link_levels(N = 500, by = join_using(primary_school, secondary_school)) ) head(students) #>   primary_school ps_quality secondary_school ss_quality students #> 1             13   7.996185               14   9.656583      001 #> 2             12   9.059026               12   7.938529      002 #> 3             12   9.059026               07   2.921166      003 #> 4             11   1.343709               15   7.867106      004 #> 5             11   1.343709               04   2.169503      005 #> 6             14   3.355842               01   5.307766      006  # Induce a correlation structure in cross-classified data by providing # rho. students <- fabricate(  primary_school = add_level(N = 20, ps_quality = runif(N, 1, 10)),  secondary_school = add_level(N = 15, ss_quality = runif(N, 1, 10), nest=FALSE),  students = link_levels(N = 500, by = join_using(ps_quality, ss_quality, rho = 0.5)) ) cor(students$ps_quality, students$ss_quality) #> [1] 0.4372795"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_binary_icc.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","title":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","text":"Data generated ensure inter-cluster correlation 0, intra-cluster correlation expectation ICC. Algorithm taken Hossein, Akhtar. \"ICCbin: R Package Facilitating Clustered Binary Data Generation, Estimation Intracluster Correlation Coefficient (ICC) Binary Data\".","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_binary_icc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","text":"","code":"draw_binary_icc(prob = 0.5, N = NULL, clusters, ICC = 0)"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_binary_icc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","text":"prob number vector numbers, one probability per cluster. none provided, default 0.5. N (Optional) number indicating number observations generated. Must equal length(clusters) provided. clusters vector factors items can coerced clusters; length determine length generated data. ICC number indicating desired ICC, none provided default ICC 0.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_binary_icc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","text":"vector binary numbers corresponding observations supplied cluster IDs.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_binary_icc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw binary data with fixed intra-cluster correlation. — draw_binary_icc","text":"","code":"# Divide units into clusters clusters = rep(1:5, 10)  # Default probability 0.5, default ICC 0 draw_binary_icc(clusters = clusters) #>  [1] 0 1 1 0 0 0 1 1 0 0 0 0 0 1 0 1 0 0 0 1 1 1 1 1 1 0 0 1 0 1 1 0 0 0 1 0 0 0 #> [39] 0 1 0 1 1 0 1 0 0 1 1 0  # Specify probability or ICC corr_draw = draw_binary_icc(prob = 0.5, clusters = clusters, ICC = 0.5)  # Verify ICC of data. summary(lm(corr_draw ~ as.factor(clusters)))$r.squared #> [1] 0.4833333"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"Drawing discrete data based probabilities latent traits common task can cumbersome. function discrete drawing set creates different type discrete data: draw_binary creates binary 0/1 data, draw_binomial creates binomial data (repeated trial binary data), draw_categorical creates categorical data, draw_ordered transforms latent data observed ordered categories, draw_count creates count data (poisson-distributed).","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"","code":"draw_binomial(   prob = link(latent),   trials = 1,   N = length(prob),   latent = NULL,   link = \"identity\",   quantile_y = NULL )  draw_categorical(   prob = link(latent),   N = NULL,   latent = NULL,   link = \"identity\",   category_labels = NULL )  draw_ordered(   x = link(latent),   breaks = c(-1, 0, 1),   break_labels = NULL,   N = length(x),   latent = NULL,   strict = FALSE,   link = \"identity\" )  draw_count(   mean = link(latent),   N = length(mean),   latent = NULL,   link = \"identity\",   quantile_y = NULL )  draw_binary(   prob = link(latent),   N = length(prob),   link = \"identity\",   latent = NULL,   quantile_y = NULL )  draw_quantile(type, N)"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"prob number vector numbers representing probability binary binomial outcomes; number, vector, matrix numbers representing probabilities categorical outcomes. supply link function, underlying probabilities transformed. trials draw_binomial, number trials observation N number units draw. Defaults length vector probabilities latent data provided. latent user provides link argument identity, provide variable latent rather prob mean link link function latent variable probability positive outcome, e.g. \"logit\", \"probit\", \"identity\". \"identity\" link, latent variable must probability. quantile_y vector quantiles; provided, rather drawing stochastically distribution interest, data drawn exactly quantiles. category_labels vector labels categories produced draw_categorical. provided, must equal number categories provided prob argument. x draw_ordered, latent data observation. breaks vector breaks cut latent outcome ordered categories draw_ordered break_labels vector labels breaks cut latent outcome ordered categories draw_ordered. (Optional) strict Logical indicating whether values outside provided breaks coded NA. Defaults FALSE, case effectively additional breaks added -Inf lowest break highest break Inf. mean draw_count, mean number count units observation type number buckets split data . median split, enter 2; terciles, enter 3; quartiles, enter 4; quintiles, 5; deciles, 10.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"vector data accordance specification; generally numeric functions, including draw_ordered draw_categorical, may factor labels provided.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"variables intra-cluster correlations, see draw_binary_icc draw_normal_icc","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw discrete variables including binary, binomial count, poisson count,\nordered, and categorical — draw_discrete","text":"","code":"# Drawing binary values (success or failure, treatment assignment) fabricate(N = 3,    p = c(0, .5, 1),    binary = draw_binary(prob = p)) #>   ID   p binary #> 1  1 0.0      0 #> 2  2 0.5      0 #> 3  3 1.0      1  # Drawing binary values with probit link (transforming continuous data # into a probability range). fabricate(N = 3,    x = 10 * rnorm(N),    binary = draw_binary(latent = x, link = \"probit\")) #>   ID           x binary #> 1  1 -20.0623503      0 #> 2  2   0.9626916      1 #> 3  3  -8.5183733      0  # Repeated trials: `draw_binomial` fabricate(N = 3,    p = c(0, .5, 1),    binomial = draw_binomial(prob = p, trials = 10)) #>   ID   p binomial #> 1  1 0.0        0 #> 2  2 0.5        8 #> 3  3 1.0       10  # Ordered data: transforming latent data into observed, ordinal data. # useful for survey responses. fabricate(N = 3,    x = 5 * rnorm(N),    ordered = draw_ordered(x = x,                           breaks = c(-Inf, -1, 1, Inf))) #>   ID         x ordered #> 1  1  2.998374       3 #> 2  2 13.871410       3 #> 3  3 -1.517144       1  # Providing break labels for latent data. fabricate(N = 3,    x = 5 * rnorm(N),    ordered = draw_ordered(x = x,                           breaks = c(-Inf, -1, 1, Inf),                           break_labels = c(\"Not at all concerned\",                                            \"Somewhat concerned\",                                            \"Very concerned\"))) #>   ID         x              ordered #> 1  1 -5.547794 Not at all concerned #> 2  2  7.428021       Very concerned #> 3  3  7.476386       Very concerned   # Count data: useful for rates of occurrences over time. fabricate(N = 5,    x = c(0, 5, 25, 50, 100),    theft_rate = draw_count(mean=x)) #>   ID   x theft_rate #> 1  1   0          0 #> 2  2   5          6 #> 3  3  25         25 #> 4  4  50         27 #> 5  5 100        102  # Categorical data: useful for demographic data. fabricate(N = 6, p1 = runif(N), p2 = runif(N), p3 = runif(N),           cat = draw_categorical(cbind(p1, p2, p3))) #>   ID        p1        p2         p3 cat #> 1  1 0.2855957 0.2075993 0.48655923   1 #> 2  2 0.9870704 0.4916528 0.22385382   1 #> 3  3 0.3346034 0.1442573 0.81235141   3 #> 4  4 0.6890801 0.3018410 0.08128565   1 #> 5  5 0.4179189 0.1910822 0.53771082   3 #> 6  6 0.3445931 0.7540574 0.01141439   2"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_likert.html","id":null,"dir":"Reference","previous_headings":"","what":"Recode a latent variable into a Likert response variable — draw_likert","title":"Recode a latent variable into a Likert response variable — draw_likert","text":"Recode latent variable Likert response variable","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_likert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recode a latent variable into a Likert response variable — draw_likert","text":"","code":"draw_likert(   x,   min = NULL,   max = NULL,   bins = NULL,   breaks = NULL,   labels = NULL )"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_likert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recode a latent variable into a Likert response variable — draw_likert","text":"x numeric variable considered \"latent\" min minimum value latent variable max maximum value latent variable bins number Likert scale values. latent variable cut equally sized bins seq(min, max, length.= bins + 1) breaks vector breaks. option useful settings equally-sized breaks inappropriate labels optional vector labels. labels provided, resulting output factor.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_likert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Recode a latent variable into a Likert response variable — draw_likert","text":"","code":"x <- 1:100  draw_likert(x, min = 0, max = 100, bins = 7) #>   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 #>  [38] 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 #>  [75] 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 draw_likert(x, breaks = c(-1, 10, 100)) #>   [1] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #>  [38] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 #>  [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_multivariate.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw multivariate random variables — draw_multivariate","title":"Draw multivariate random variables — draw_multivariate","text":"Draw multivariate random variables","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_multivariate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw multivariate random variables — draw_multivariate","text":"","code":"draw_multivariate(formula, sep = \"_\")"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_multivariate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw multivariate random variables — draw_multivariate","text":"formula Formula describing multivariate draw. lefthand side names prefix right-hand side multivariate draw function call, mvrnorm MASS library rmnom extraDistr library. sep Separator string prefix variable number. used single character string provided multiple variables created.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_multivariate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw multivariate random variables — draw_multivariate","text":"tibble","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_multivariate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw multivariate random variables — draw_multivariate","text":"","code":"library(MASS)  # draw from multivariate normal distribution dat <-   draw_multivariate(c(Y_1, Y_2) ~ mvrnorm(     n = 500,     mu = c(0, 0),     Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)   ))   cor(dat) #>           Y_1       Y_2 #> Y_1 1.0000000 0.5380296 #> Y_2 0.5380296 1.0000000   # equivalently, you can provide a prefix for the variable names # (easier if you have many variables) draw_multivariate(Y ~ mvrnorm(   n = 5,   mu = c(0, 0),   Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2) )) #>           Y_1        Y_2 #> 1 -0.78262833 -0.1862132 #> 2  0.05617033 -0.9099106 #> 3 -0.43498299 -1.1824282 #> 4  0.08306032  0.5056838 #> 5 -0.13086905 -1.0908213  # within fabricate fabricate(   N = 100,   draw_multivariate(c(Y_1, Y_2) ~ mvrnorm(     n = N,     mu = c(0, 0),     Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2)   )) ) #>      ID         Y_1           Y_2 #> 1   001 -0.33221088 -0.7414417752 #> 2   002  1.49644849  1.0875750212 #> 3   003  1.28297610  0.6295161371 #> 4   004 -1.66786860 -0.8994084045 #> 5   005  1.57586878 -0.3976454861 #> 6   006 -0.68381107 -1.0916153945 #> 7   007  1.15501407  1.1357798064 #> 8   008  0.64421193 -1.3023150385 #> 9   009 -0.20043296  0.8720061536 #> 10  010 -0.76057114  0.3119527536 #> 11  011 -0.21882197 -0.4345328763 #> 12  012 -1.64526360 -0.5852904758 #> 13  013 -0.45052863 -0.2066925166 #> 14  014  0.92533496  1.2883318161 #> 15  015 -0.90713996 -0.9014431949 #> 16  016  0.30834273  1.0137192617 #> 17  017  0.73492670  0.4697790587 #> 18  018 -0.41155383 -0.9911153559 #> 19  019  1.40096715  1.9637949442 #> 20  020  0.57554054  1.7256850074 #> 21  021  0.01327834 -0.2162607667 #> 22  022  0.07726589  0.3524825581 #> 23  023  0.39428279 -0.2461639603 #> 24  024  0.06219582 -0.2476440258 #> 25  025  1.72243010 -0.1774026931 #> 26  026  1.51586483  2.2847001359 #> 27  027 -0.53095234 -0.6252925975 #> 28  028 -0.87498416 -0.4003366020 #> 29  029 -0.35917592 -2.6215608205 #> 30  030 -1.27502207  0.4254418998 #> 31  031 -0.45744631 -0.5644669435 #> 32  032 -1.12760778 -0.4960262814 #> 33  033 -2.39888616 -0.1418522864 #> 34  034 -0.06000971 -0.2288784373 #> 35  035 -0.86812708 -1.6278467129 #> 36  036  2.34018018  1.3689745280 #> 37  037  0.26904237 -0.6089793381 #> 38  038 -0.55665051  0.4244197817 #> 39  039  0.26096177 -0.4507603413 #> 40  040  0.72072585  1.3440822521 #> 41  041  0.07587477 -0.3915524561 #> 42  042 -1.28897767 -0.4496490716 #> 43  043 -0.11244534 -0.8530702120 #> 44  044 -0.06231243  1.7021547936 #> 45  045 -0.67507804 -1.6553755302 #> 46  046 -1.29925585  0.6210671168 #> 47  047  0.28097894  0.8672602082 #> 48  048 -0.26341992 -1.1417808094 #> 49  049  1.44353986  0.9287740690 #> 50  050  0.01833485 -1.8122653198 #> 51  051 -1.89771907 -0.1459432866 #> 52  052  1.30347094  0.0003869112 #> 53  053 -1.58296229 -1.1103130068 #> 54  054 -0.41782554  0.8726877458 #> 55  055  0.92313065  1.3927191507 #> 56  056  0.32546934 -0.2252733789 #> 57  057  0.18209285  1.6743068710 #> 58  058  1.29353154 -0.3528319799 #> 59  059 -1.02501583 -1.5211780223 #> 60  060 -0.61799710 -1.3891023727 #> 61  061 -0.79949472  0.1645561244 #> 62  062 -1.33863972  0.3119490638 #> 63  063  1.43803101  0.3704746144 #> 64  064 -0.52177490 -0.3917805612 #> 65  065 -0.78846752 -0.1279525557 #> 66  066 -0.85738728  0.6863893024 #> 67  067  2.32093306  1.7449529959 #> 68  068  0.52171999 -0.4425804818 #> 69  069  0.94224513 -0.1613622402 #> 70  070  0.79392201 -0.7868842999 #> 71  071 -0.02444483 -0.6665633492 #> 72  072  0.50328264  1.8875631300 #> 73  073  0.15935727  0.6464310533 #> 74  074 -1.52677753 -1.4201666379 #> 75  075 -1.73300253 -0.7275126051 #> 76  076 -1.07717249 -0.3375119063 #> 77  077 -0.23459340  0.3843938055 #> 78  078  1.28182650  0.6367439690 #> 79  079 -0.92395329 -1.2501116047 #> 80  080 -0.71183924 -0.5027359136 #> 81  081  0.49142309 -0.5457241043 #> 82  082 -0.67340547 -1.9560133442 #> 83  083 -0.10327719 -0.0030650593 #> 84  084 -0.45759455 -0.7489548007 #> 85  085  2.21410260  2.0917864319 #> 86  086  1.52415038  1.1732675636 #> 87  087  0.80306980  1.2856077725 #> 88  088 -0.14737225 -0.7072613829 #> 89  089 -1.06212515  0.4691943414 #> 90  090  0.63882932  0.3049350203 #> 91  091  0.47517870  1.2455003188 #> 92  092 -1.85665235 -0.5836588640 #> 93  093  1.25799688  1.2999026970 #> 94  094 -0.66545585  0.0679543638 #> 95  095 -0.47622941 -0.0621871356 #> 96  096  1.84106670  0.3885357464 #> 97  097 -0.40588041 -0.8056995036 #> 98  098  0.01825417  0.1346212195 #> 99  099 -1.50951853  0.2524428465 #> 100 100 -0.21939663  0.0890836707  # You can also write the following, which works but gives less control over the names fabricate(N = 100, Y = mvrnorm(   n = N,   mu = c(0, 0),   Sigma = matrix(c(1, 0.5, 0.5, 1), 2, 2) )) #>      ID         Y.1         Y.2 #> 1   001 -1.61283623 -1.02827708 #> 2   002 -1.86978287  0.42712239 #> 3   003 -0.77630360  0.46894695 #> 4   004 -0.93234982  0.80414128 #> 5   005  0.55993828 -1.02316815 #> 6   006  1.47687264  1.43495239 #> 7   007  1.23616370  0.67631193 #> 8   008  2.48527128  1.82513134 #> 9   009  0.83060622  1.11796639 #> 10  010  0.87516566 -0.30436633 #> 11  011 -0.29683487 -1.22466503 #> 12  012 -0.49864623  0.63509510 #> 13  013 -0.32963379  0.82975535 #> 14  014  0.52808637 -0.12240684 #> 15  015 -0.04953976  0.78425987 #> 16  016  0.50358926  1.16515919 #> 17  017 -0.57634186 -0.74284327 #> 18  018 -1.15549588 -1.05837852 #> 19  019  0.12979226  0.81859896 #> 20  020  0.91453166 -1.12924479 #> 21  021  1.22059189  1.29234932 #> 22  022 -0.70921727  0.10931447 #> 23  023  2.10219051  1.11573352 #> 24  024 -1.03221492 -1.18639921 #> 25  025  1.68840761  1.15441585 #> 26  026 -0.01059499 -0.13459100 #> 27  027 -1.28377058 -1.29531739 #> 28  028 -0.77098930  0.50053719 #> 29  029 -0.05073303 -0.01272229 #> 30  030 -0.48182436 -0.41141892 #> 31  031  0.92869579  1.61911010 #> 32  032 -1.19029656 -1.94281151 #> 33  033 -0.43342799 -0.28399262 #> 34  034 -1.73850855  0.05651461 #> 35  035 -1.23790650 -0.32869927 #> 36  036 -0.33529162  0.37548796 #> 37  037  0.35980289  0.46997733 #> 38  038 -0.63205447  0.47155514 #> 39  039 -0.10235096  0.02132494 #> 40  040 -0.28408046  1.65297819 #> 41  041  0.78765990  1.96514469 #> 42  042  0.42470364 -0.74136163 #> 43  043  0.64305019 -1.68075018 #> 44  044 -0.82848974 -0.54747600 #> 45  045  0.29784015  0.97556154 #> 46  046 -0.78330247 -0.44982183 #> 47  047 -0.53469460 -1.21901764 #> 48  048  0.30158984  0.52262435 #> 49  049  0.09976344  1.35015918 #> 50  050 -0.67120817 -0.43561879 #> 51  051  2.75140748  2.72438268 #> 52  052 -1.19261623 -1.91050241 #> 53  053 -0.11529681  0.05595876 #> 54  054 -0.10960121  1.30543528 #> 55  055 -0.90960309 -0.21197810 #> 56  056 -1.50970805 -1.45078730 #> 57  057  0.72120072  0.58831775 #> 58  058  0.42140458 -0.36655440 #> 59  059 -1.03034999 -0.29523693 #> 60  060  0.60576106  1.07247804 #> 61  061  0.14445508  0.18992460 #> 62  062 -0.26668218 -0.70733547 #> 63  063  0.37423725  0.49534094 #> 64  064 -0.74641909  0.71595754 #> 65  065 -0.47962878  0.09095007 #> 66  066 -0.13665854 -0.34910984 #> 67  067  0.36178945 -0.10087704 #> 68  068 -0.81732040  1.46727298 #> 69  069 -0.39912906  0.76049596 #> 70  070  0.22815004 -0.44312399 #> 71  071 -0.47162190 -0.66298895 #> 72  072  2.64890105  1.46857748 #> 73  073  0.99967598  0.51115917 #> 74  074 -1.62255518 -0.36228996 #> 75  075  1.27305744  0.12573067 #> 76  076 -1.11033565 -0.45765458 #> 77  077  0.02309524 -0.56314305 #> 78  078 -2.14457649 -0.49932284 #> 79  079 -0.05429208 -1.32841987 #> 80  080  0.61829417  1.75996245 #> 81  081  1.66701593 -0.62634769 #> 82  082 -0.72842964 -1.12575821 #> 83  083  2.06505100  1.46301910 #> 84  084 -0.53515026 -0.48027813 #> 85  085 -0.62075328 -1.20191618 #> 86  086  1.63647894 -0.90010483 #> 87  087 -0.66690286  1.25627237 #> 88  088 -0.42990237 -1.24827213 #> 89  089 -0.49565982  0.64959187 #> 90  090  1.45041489  0.98549965 #> 91  091 -0.09031577 -0.49121188 #> 92  092  0.17879486  0.48148419 #> 93  093 -0.66268971 -0.33617251 #> 94  094 -0.39888700 -0.62827777 #> 95  095 -0.59446885  0.47795339 #> 96  096  0.80295422 -0.91065295 #> 97  097  0.08485752  0.17518790 #> 98  098 -0.58967601 -0.42762169 #> 99  099 -0.74902521 -0.59360750 #> 100 100 -0.50741070 -0.75554468"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":null,"dir":"Reference","previous_headings":"","what":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"Data generated ensure inter-cluster correlation 0, intra-cluster correlation expectation ICC. data generating process used function specified following URL: https://stats.stackexchange.com/questions/263451/create-synthetic-data---given-intraclass-correlation-coefficient-icc","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"","code":"draw_normal_icc(   mean = 0,   N = NULL,   clusters,   sd = NULL,   sd_between = NULL,   total_sd = NULL,   ICC = NULL )"},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"mean number vector numbers, one mean per cluster. none provided, default 0. N (Optional) number indicating number observations generated. Must equal length(clusters) provided. clusters vector factors items can coerced clusters; length determine length generated data. sd number vector numbers, indicating standard deviation cluster's error terms -- standard deviation within cluster (default 1) sd_between number vector numbers, indicating standard deviation clusters. total_sd number indicating total sd resulting variable. May specified ICC specified sd sd_between . ICC number indicating desired ICC.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"vector numbers corresponding observations supplied cluster IDs.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"typical use function user provide ICC , optionally, set within-cluster standard deviations, sd. user provide sd, default value 1. arguments imply fixed -cluster standard deviation. alternate mode function provide -cluster standard deviations, sd_between, ICC. arguments imply fixed within-cluster standard deviation. users provide three ICC, sd_between, sd, function warn user use provided standard deviations generating data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/draw_normal_icc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Draw normal data with fixed intra-cluster correlation. — draw_normal_icc","text":"","code":"# Divide observations into clusters clusters = rep(1:5, 10)  # Default: unit variance within each cluster draw_normal_icc(clusters = clusters, ICC = 0.5) #>  [1]  0.49450296  1.76326530 -0.55723878  0.08719267 -0.58982440  0.41187134 #>  [7]  0.31681196 -2.48155338 -2.05668730  0.48163113  0.67683591  0.50503756 #> [13] -3.44068085 -1.58009973 -1.99125551  0.87100508  0.63747316 -1.10026840 #> [19]  0.91781115 -0.22907482 -0.03180804  2.44883539  1.54599058 -1.59685492 #> [25] -1.13602622  0.46173735  1.21439851 -2.15201588 -1.39765489 -1.10040712 #> [31]  0.78269256 -1.73290466 -1.24014900 -0.05607784  0.35269798  0.07022130 #> [37] -0.86342067 -0.33794203 -2.14468846  2.90714464  0.44008625  0.82500833 #> [43] -0.72053203 -0.06855008 -0.27195064  0.46892913  0.63223643 -2.73495496 #> [49] -0.67569203  0.21638484  # Alternatively, you can specify characteristics: draw_normal_icc(mean = 10, clusters = clusters, sd = 3, ICC = 0.3) #>  [1]  8.992799  5.836268  9.646364 15.712887  6.046423  4.528281 18.739017 #>  [8] 11.319318 14.432769 14.424811  7.875074  1.075277 11.836508  4.062464 #> [15] 13.959939 10.290885  6.737884 11.662991 10.001451 10.530494 13.955500 #> [22]  7.654693 11.135830  8.791852 13.262444  5.079954  8.483116  8.023099 #> [29] 13.643348 13.184658  8.847046  7.308258 11.910012 15.368235  4.974050 #> [36] 13.123873  8.798924  8.177686 11.880163 12.124097  2.255502  9.853272 #> [43]  7.899634 13.256797 15.299892  9.667233  9.858879 12.275391  5.719877 #> [50] 11.042171  # Can specify between-cluster standard deviation instead: draw_normal_icc(clusters = clusters, sd_between = 4, ICC = 0.2) #>  [1]  -7.0161242   2.2637241  -6.0678605  13.0269489 -12.9155057  -4.6323822 #>  [7]  12.6146813  -2.2860220 -15.7113355  -3.5728355  -4.2883575  -7.3617796 #> [13]  11.0031561  -9.8653074   3.9161756  -1.2014407   8.1175695  -0.7503631 #> [19] -13.0781979  -1.2563850 -18.0520004  10.5115877  -5.4695698 -10.0045940 #> [25]   7.5232486  -3.9016369  12.4386966  20.5090791 -15.5414033   9.0884797 #> [31]  -8.4246907  24.0667158  -0.8491765 -17.2169570 -11.4263821  -2.4347574 #> [37]   7.6044161   5.8371619  -0.5230782   8.7462005  -9.9910095   7.9373810 #> [43]   4.6591841   1.1189162  11.4303420   1.3044758  -0.2229242   2.4042641 #> [49]  -4.5025304   9.0638419  # Can specify total SD instead: total_sd_draw = draw_normal_icc(clusters = clusters, ICC = 0.5, total_sd = 3) sd(total_sd_draw) #> [1] 3  # Verify that ICC generated is accurate corr_draw = draw_normal_icc(clusters = clusters, ICC = 0.4) summary(lm(corr_draw ~ as.factor(clusters)))$r.squared #> [1] 0.2097463"},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":null,"dir":"Reference","previous_headings":"","what":"Fabricate data — fabricate","title":"Fabricate data — fabricate","text":"fabricate helps simulate dataset collect . can either start data add simulated variables (passing data fabricate()) start scratch defining N. Create hierarchical data multiple levels data citizens within cities within states using add_level() modify existing hierarchical data using modify_level(). can use R function create variable. Use cross_levels() link_levels() make complex designs panel cross-classified data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fabricate data — fabricate","text":"","code":"fabricate(..., data = NULL, N = NULL, ID_label = NULL)  add_level(N = NULL, ..., nest = TRUE)  modify_level(..., by = NULL)  nest_level(N = NULL, ...)"},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fabricate data — fabricate","text":"... Variable level-generating arguments, my_var = rnorm(N). fabricate, may also pass add_level() modify_level() arguments, define level multi-level dataset. See examples. data (optional) user-provided data forms basis fabrication, e.g. can add variables existing data. Provide either N data (N number rows data data provided). data N provided, fabricatr try interpret first un-named argument either data N based type. N (optional) number units draw. provided fabricate(N = 5), determines number units single-level data. provided add_level, e.g. fabricate(cities = add_level(N = 5)), N determines number units specific level hierarchical dataset. ID_label (optional) variable name ID variable, e.g. citizen_ID. Set NA suppress creation ID variable. nest (Default TRUE) Boolean determining whether data add_level() call nested current working data frame create separate hierarchy levels. See vignette cross-classified, non-nested data details. (optional) quoted name variable modify_level uses split-modify-combine data .","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fabricate data — fabricate","text":"data.frame","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fabricate data — fabricate","text":"also provide several built-options easily create variables, including draw_binary, draw_count, draw_likert, intra-cluster correlated variables draw_binary_icc draw_normal_icc","code":""},{"path":[]},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fabricate data — fabricate","text":"","code":"# Draw a single-level dataset with a covariate building_df <- fabricate(   N = 100,   height_ft = runif(N, 300, 800) ) head(building_df) #>    ID height_ft #> 1 001  589.7833 #> 2 002  638.5082 #> 3 003  674.6124 #> 4 004  368.7422 #> 5 005  491.7854 #> 6 006  521.8952  # Start with existing data instead building_modified <- fabricate(   data = building_df,   rent = rnorm(N, mean = height_ft * 100, sd = height_ft * 30) )  # Draw a two-level hierarchical dataset # containing cities within regions multi_level_df <- fabricate(  regions = add_level(N = 5),  cities = add_level(N = 2, pollution = rnorm(N, mean = 5))) head(multi_level_df) #>   regions cities pollution #> 1       1     01  4.515322 #> 2       1     02  4.352685 #> 3       2     03  5.451505 #> 4       2     04  6.222524 #> 5       3     05  5.417486 #> 6       3     06  5.446253  # Start with existing data and add a nested level: company_df <- fabricate(  data = building_df,  company_id = add_level(N=10, is_headquarters = sample(c(0, 1), N, replace=TRUE)) )  # Start with existing data and add variables to hierarchical data # at levels which are already present in the existing data. # Note: do not provide N when adding variables to an existing level fabricate(   data = multi_level_df,   regions = modify_level(watershed = sample(c(0, 1), N, replace = TRUE)),   cities = modify_level(runoff = rnorm(N)) ) #>    regions cities pollution watershed    runoff #> 1        1     01  4.515322         1 0.9115688 #> 2        1     02  4.352685         1 1.3571120 #> 3        2     03  5.451505         1 0.7772347 #> 4        2     04  6.222524         1 1.2347851 #> 5        3     05  5.417486         0 1.2311819 #> 6        3     06  5.446253         1 0.3721503 #> 7        4     07  4.867138         1 0.7266624 #> 8        4     08  4.810035         0 1.6478770 #> 9        5     09  5.465945         0 0.6443804 #> 10       5     10  4.508268         0 1.2834544  # fabricatr can add variables that are higher-level summaries of lower-level # variables via a split-modify-combine logic and the \\code{by} argument  multi_level_df <-  fabricate(    regions = add_level(N = 5, elevation = rnorm(N)),    cities = add_level(N = 2, pollution = rnorm(N, mean = 5)),    cities = modify_level(by = \"regions\", regional_pollution = mean(pollution))  )  # fabricatr can also make panel or cross-classified data. For more # information about syntax for this functionality please read our vignette # or check documentation for \\code{link_levels}: cross_classified <- fabricate(   primary_schools = add_level(N = 50, ps_quality = runif(N, 0, 10)),   secondary_schools = add_level(N = 100, ss_quality = runif(N, 0, 10), nest=FALSE),   students = link_levels(N = 2000,                           by = join_using(ps_quality, ss_quality, rho = 0.5),                           student_quality = ps_quality + 3*ss_quality + rnorm(N)))"},{"path":"https://declaredesign.org/r/fabricatr/reference/fabricatr.html","id":null,"dir":"Reference","previous_headings":"","what":"fabricatr package — fabricatr","title":"fabricatr package — fabricatr","text":"fabricatr helps imagine data collect . Hierarchical data structures correlated data can easily simulated, either random number generators resampling existing data sources.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/get_unique_variables_by_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Find which variables are unique at a given level in hierarchical data — get_unique_variables_by_level","title":"Find which variables are unique at a given level in hierarchical data — get_unique_variables_by_level","text":"Find variables unique given level hierarchical data","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/get_unique_variables_by_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find which variables are unique at a given level in hierarchical data — get_unique_variables_by_level","text":"","code":"get_unique_variables_by_level(data, ID_label, superset = NULL)"},{"path":"https://declaredesign.org/r/fabricatr/reference/get_unique_variables_by_level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find which variables are unique at a given level in hierarchical data — get_unique_variables_by_level","text":"data data.frame ID_label ID label split upon superset Superset contains vector character strings contain variables modify level call going write. may columns data frame, others might . superset specified, definitely want check variables","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/get_unique_variables_by_level.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find which variables are unique at a given level in hierarchical data — get_unique_variables_by_level","text":"character vector enumerating unique variables","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/join_using.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function handling specification of which variables to join a\ncross-classified data on, and what kind of correlation structure needed.\nCorrelation structures can only be provided if the underlying call is\na link_levels() call. — join_using","title":"Helper function handling specification of which variables to join a\ncross-classified data on, and what kind of correlation structure needed.\nCorrelation structures can only be provided if the underlying call is\na link_levels() call. — join_using","text":"Helper function handling specification variables join cross-classified data , kind correlation structure needed. Correlation structures can provided underlying call link_levels() call.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/join_using.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function handling specification of which variables to join a\ncross-classified data on, and what kind of correlation structure needed.\nCorrelation structures can only be provided if the underlying call is\na link_levels() call. — join_using","text":"","code":"join_using(..., rho = 0, sigma = NULL)"},{"path":"https://declaredesign.org/r/fabricatr/reference/join_using.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function handling specification of which variables to join a\ncross-classified data on, and what kind of correlation structure needed.\nCorrelation structures can only be provided if the underlying call is\na link_levels() call. — join_using","text":"... series two variable names, unquoted, join order create cross-classified data. rho fixed (Spearman's rank) correlation coefficient variables joined : note possible make correlation matrix coefficient (e.g. joining three variables rho negative) cross_levels() call fail. provide rho making panel data. sigma matrix dimensions equal number variables joining , specifying correlation resulting joined data. one rho sigma provided. provide sigma making panel data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/join_using.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper function handling specification of which variables to join a\ncross-classified data on, and what kind of correlation structure needed.\nCorrelation structures can only be provided if the underlying call is\na link_levels() call. — join_using","text":"","code":"panels <- fabricate(   countries = add_level(N = 150, country_fe = runif(N, 1, 10)),   years = add_level(N = 25, year_shock = runif(N, 1, 10), nest = FALSE),   obs = cross_levels(     by = join_using(countries, years),     new_variable = country_fe + year_shock + rnorm(N, 0, 2)   ) )  schools_data <- fabricate(   primary_schools = add_level(N = 20, ps_quality = runif(N, 1, 10)),   secondary_schools = add_level(     N = 15,     ss_quality = runif(N, 1, 10),     nest = FALSE),   students = link_levels(     N = 1500,     by = join_using(primary_schools, secondary_schools),     SAT_score = 800 + 13 * ps_quality + 26 * ss_quality + rnorm(N, 0, 50)   ) )"},{"path":"https://declaredesign.org/r/fabricatr/reference/potential_outcomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Build potential outcomes variables — potential_outcomes","title":"Build potential outcomes variables — potential_outcomes","text":"Function draw multiple potential outcomes, one condition assignment variable can set .","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/potential_outcomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build potential outcomes variables — potential_outcomes","text":"","code":"potential_outcomes(x, conditions = list(Z = c(0, 1)), sep = \"_\")"},{"path":"https://declaredesign.org/r/fabricatr/reference/potential_outcomes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build potential outcomes variables — potential_outcomes","text":"x Formula describing potential outcomes outcome name left hand side expression describing potential outcomes right hand side, e.g. Y ~ 0.1 * Z + rnorm(N) (draw two potential outcomes columns default, named Y_Z_0 Y_Z_1). conditions list conditions assignment variable. Defaults list(Z = c(0, 1)). sep Separator inserted outcome name assignment variable name used construct potential outcome variable names, defaults \"_\".","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/potential_outcomes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build potential outcomes variables — potential_outcomes","text":"","code":"fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z + U) ) #>    ID           U       Y_Z_0       Y_Z_1 #> 1  01  0.84289307  0.84289307  0.94289307 #> 2  02 -0.34188744 -0.34188744 -0.24188744 #> 3  03  1.34562011  1.34562011  1.44562011 #> 4  04 -0.08570210 -0.08570210  0.01429790 #> 5  05  1.91155195  1.91155195  2.01155195 #> 6  06  0.15389890  0.15389890  0.25389890 #> 7  07  0.12684362  0.12684362  0.22684362 #> 8  08 -0.49233079 -0.49233079 -0.39233079 #> 9  09 -0.07486076 -0.07486076  0.02513924 #> 10 10 -0.75127989 -0.75127989 -0.65127989  # equivalently,  fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z + U,                      conditions = list(Z = c(0, 1))) ) #>    ID          U      Y_Z_0       Y_Z_1 #> 1  01 -1.2069148 -1.2069148 -1.10691483 #> 2  02  0.3399769  0.3399769  0.43997694 #> 3  03 -0.9885617 -0.9885617 -0.88856173 #> 4  04  1.2038892  1.2038892  1.30388925 #> 5  05  0.4009289  0.4009289  0.50092895 #> 6  06 -0.3143315 -0.3143315 -0.21433151 #> 7  07  1.9956207  1.9956207  2.09562065 #> 8  08  0.8200451  0.8200451  0.92004509 #> 9  09 -0.6376240 -0.6376240 -0.53762404 #> 10 10 -0.1759608 -0.1759608 -0.07596076  fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z + U,                      conditions = list(Z = c(1, 2, 3))) ) #>    ID           U       Y_Z_1       Y_Z_2       Y_Z_3 #> 1  01 -0.47246994 -0.37246994 -0.27246994 -0.17246994 #> 2  02  1.71209680  1.81209680  1.91209680  2.01209680 #> 3  03  0.24663324  0.34663324  0.44663324  0.54663324 #> 4  04 -0.39376525 -0.29376525 -0.19376525 -0.09376525 #> 5  05 -0.33082327 -0.23082327 -0.13082327 -0.03082327 #> 6  06  0.16430748  0.26430748  0.36430748  0.46430748 #> 7  07 -0.14218686 -0.04218686  0.05781314  0.15781314 #> 8  08 -0.82618553 -0.72618553 -0.62618553 -0.52618553 #> 9  09 -1.42331823 -1.32331823 -1.22331823 -1.12331823 #> 10 10 -0.04382842  0.05617158  0.15617158  0.25617158  fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z1 + 0.3 * Z2 + 0.5 * Z1 * Z2 + U,                      conditions = list(Z1 = c(0, 1),                                        Z2 = c(0, 1))) ) #>    ID           U Y_Z1_0_Z2_0 Y_Z1_1_Z2_0 Y_Z1_0_Z2_1 Y_Z1_1_Z2_1 #> 1  01 -0.11648526 -0.11648526 -0.01648526   0.1835147   0.7835147 #> 2  02  0.90362515  0.90362515  1.00362515   1.2036252   1.8036252 #> 3  03  0.03087798  0.03087798  0.13087798   0.3308780   0.9308780 #> 4  04  0.64262327  0.64262327  0.74262327   0.9426233   1.5426233 #> 5  05  0.79159133  0.79159133  0.89159133   1.0915913   1.6915913 #> 6  06 -0.54103746 -0.54103746 -0.44103746  -0.2410375   0.3589625 #> 7  07  0.87241687  0.87241687  0.97241687   1.1724169   1.7724169 #> 8  08  1.21437682  1.21437682  1.31437682   1.5143768   2.1143768 #> 9  09  0.48147071  0.48147071  0.58147071   0.7814707   1.3814707 #> 10 10 -0.63357917 -0.63357917 -0.53357917  -0.3335792   0.2664208"},{"path":"https://declaredesign.org/r/fabricatr/reference/recycle.html","id":null,"dir":"Reference","previous_headings":"","what":"Expands data to a given length through recycling. — recycle","title":"Expands data to a given length through recycling. — recycle","text":"function helper function designed call rep_len expand length data vector, can dynamically retrieve N surrounding level call use fabricatr.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/recycle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expands data to a given length through recycling. — recycle","text":"","code":"recycle(x, .N = NULL)"},{"path":"https://declaredesign.org/r/fabricatr/reference/recycle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expands data to a given length through recycling. — recycle","text":"x Data recycle length N .N length recycle data , typically provided implicitly fabricate call wrapped around function call.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/recycle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expands data to a given length through recycling. — recycle","text":"vector data padded length N","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/recycle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expands data to a given length through recycling. — recycle","text":"","code":"fabricate(   N = 15,   month = recycle(month.abb) ) #>    ID month #> 1  01   Jan #> 2  02   Feb #> 3  03   Mar #> 4  04   Apr #> 5  05   May #> 6  06   Jun #> 7  07   Jul #> 8  08   Aug #> 9  09   Sep #> 10 10   Oct #> 11 11   Nov #> 12 12   Dec #> 13 13   Jan #> 14 14   Feb #> 15 15   Mar"},{"path":"https://declaredesign.org/r/fabricatr/reference/resample_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Resample data, including hierarchical data — resample_data","title":"Resample data, including hierarchical data — resample_data","text":"function allows resample data frame. default mode performs single resample size N replacement. Users can also specify complex resampling strategies resample hierarchical data.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/resample_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resample data, including hierarchical data — resample_data","text":"","code":"resample_data(data, N, ID_labels = NULL, unique_labels = FALSE)"},{"path":"https://declaredesign.org/r/fabricatr/reference/resample_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resample data, including hierarchical data — resample_data","text":"data data.frame, usually provided user. N number sample observations return. N single scalar labels provided, N specify number unit observations resample. N named, ID_labels argument specified (case, N ID_labels length), units resampled values levels resampled (useful , e.g., cluster resampling). N constant level, units level transparently passed next level resampling. ID_labels character vector variables indicate data hierarchy, highest lowest (.e., cities citizens). unique_labels boolean, defaulting FALSE. TRUE, fabricatr created extra data frame column depicting unique version ID_label variable resampled , called <ID_label>_unique.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/resample_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resample data, including hierarchical data — resample_data","text":"data.frame","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/resample_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Resample data, including hierarchical data — resample_data","text":"","code":"# Resample a dataset of size N without any hierarchy baseline_survey <- fabricate(N = 50, Y_pre = rnorm(N)) bootstrapped_data <- resample_data(baseline_survey)  # Specify a fixed number of observations to return baseline_survey <- fabricate(N = 50, Y_pre = rnorm(N)) bootstrapped_data <- resample_data(baseline_survey, N = 100)  # Resample by a single level of a hierarchical dataset (e.g. resampling # clusters of observations): N specifies a number of clusters to return  clustered_survey <- fabricate(   clusters = add_level(N=25),   cities = add_level(N=round(runif(25, 1, 5)),                      population=runif(n = N, min=50000, max=1000000)) )  cluster_resample <- resample_data(clustered_survey, N = 5, ID_labels = \"clusters\")  # Alternatively, pass the level to resample as a name: cluster_resample_2 <- resample_data(clustered_survey, N=c(clusters = 5))  # Resample a hierarchical dataset on multiple levels my_data <- fabricate(   cities = add_level(N = 20, elevation = runif(n = N, min = 1000, max = 2000)),   citizens = add_level(N = 30, age = runif(n = N, min = 18, max = 85)) )  # Specify the levels you wish to resample: my_data_2 <- resample_data(my_data, N = c(3, 5),                            ID_labels = c(\"cities\", \"citizens\"))  # To resample every unit at a given level, use the ALL constant # This example will resample 10 citizens at each of the cities:  passthrough_resample_data <- resample_data(my_data, N = c(cities=ALL, citizens=10))  # To ensure a column with unique labels (for example, to calculate block-level # statistics irrespective of sample choices), use the unique_labels=TRUE # argument -- this will produce new columns with unique labels.  unique_resample <- resample_data(my_data, N = c(cities=5), unique_labels = TRUE)"},{"path":"https://declaredesign.org/r/fabricatr/reference/reveal_outcomes.html","id":null,"dir":"Reference","previous_headings":"","what":"Reveal outcomes — reveal_outcomes","title":"Reveal outcomes — reveal_outcomes","text":"Implements generalized switching equation. Reveals observed outcomes multiple potential outcomes variables assignment variable.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/reveal_outcomes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reveal outcomes — reveal_outcomes","text":"","code":"reveal_outcomes(x)"},{"path":"https://declaredesign.org/r/fabricatr/reference/reveal_outcomes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reveal outcomes — reveal_outcomes","text":"x formula outcome name left hand side assignment variables right hand side (e.g., Y ~ Z).","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/reveal_outcomes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reveal outcomes — reveal_outcomes","text":"","code":"dat <- fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z + U) )  fabricate(   data = dat,   Z = rbinom(N, 1, prob = 0.5),   Y = reveal_outcomes(Y ~ Z) ) #>    ID           U       Y_Z_0       Y_Z_1 Z           Y #> 1  01 -0.77594212 -0.77594212 -0.67594212 0 -0.77594212 #> 2  02 -0.78370898 -0.78370898 -0.68370898 0 -0.78370898 #> 3  03 -1.62232298 -1.62232298 -1.52232298 1 -1.52232298 #> 4  04 -0.19088834 -0.19088834 -0.09088834 1 -0.09088834 #> 5  05  0.20614823  0.20614823  0.30614823 0  0.20614823 #> 6  06 -0.05433129 -0.05433129  0.04566871 1  0.04566871 #> 7  07  0.99972605  0.99972605  1.09972605 1  1.09972605 #> 8  08  0.98150866  0.98150866  1.08150866 1  1.08150866 #> 9  09 -0.57675797 -0.57675797 -0.47675797 1 -0.47675797 #> 10 10 -0.90732264 -0.90732264 -0.80732264 1 -0.80732264  fabricate(   N = 10,   U = rnorm(N),   potential_outcomes(Y ~ 0.1 * Z1 + 0.3 * Z2 + 0.5 * Z1 * Z2 + U,                      conditions = list(Z1 = c(0, 1),                                        Z2 = c(0, 1))),   Z1 = rbinom(N, 1, prob = 0.5),   Z2 = rbinom(N, 1, prob = 0.5),   Y = reveal_outcomes(Y ~ Z1 + Z2) ) #>    ID           U Y_Z1_0_Z2_0 Y_Z1_1_Z2_0 Y_Z1_0_Z2_1 Y_Z1_1_Z2_1 Z1 Z2 #> 1  01  0.30864851  0.30864851  0.40864851   0.6086485  1.20864851  1  1 #> 2  02  0.23320038  0.23320038  0.33320038   0.5332004  1.13320038  1  1 #> 3  03 -0.98589852 -0.98589852 -0.88589852  -0.6858985 -0.08589852  0  0 #> 4  04  0.33205781  0.33205781  0.43205781   0.6320578  1.23205781  0  0 #> 5  05 -0.17644861 -0.17644861 -0.07644861   0.1235514  0.72355139  0  0 #> 6  06  0.20784964  0.20784964  0.30784964   0.5078496  1.10784964  1  0 #> 7  07  1.57973127  1.57973127  1.67973127   1.8797313  2.47973127  0  1 #> 8  08 -0.78430732 -0.78430732 -0.68430732  -0.4843073  0.11569268  0  1 #> 9  09 -0.47925355 -0.47925355 -0.37925355  -0.1792535  0.42074645  0  1 #> 10 10  0.04140505  0.04140505  0.14140505   0.3414051  0.94140505  0  0 #>              Y #> 1   1.20864851 #> 2   1.13320038 #> 3  -0.98589852 #> 4   0.33205781 #> 5  -0.17644861 #> 6   0.30784964 #> 7   1.87973127 #> 8  -0.48430732 #> 9  -0.17925355 #> 10  0.04140505"},{"path":"https://declaredesign.org/r/fabricatr/reference/split_quantile.html","id":null,"dir":"Reference","previous_headings":"","what":"Split data into quantile buckets (e.g. terciles, quartiles, quantiles,\ndeciles). — split_quantile","title":"Split data into quantile buckets (e.g. terciles, quartiles, quantiles,\ndeciles). — split_quantile","text":"Survey data often presented aggregated, depersonalized form, can involve binning underlying data quantile buckets; example, rather reporting underlying income, survey might report income decile. split_quantile can automatically produce split using data x number splits `type.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/split_quantile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split data into quantile buckets (e.g. terciles, quartiles, quantiles,\ndeciles). — split_quantile","text":"","code":"split_quantile(x = NULL, type = NULL)"},{"path":"https://declaredesign.org/r/fabricatr/reference/split_quantile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split data into quantile buckets (e.g. terciles, quartiles, quantiles,\ndeciles). — split_quantile","text":"x vector type can ordered -- .e. numeric factor factor levels ordered. type number buckets split data . median split, enter 2; terciles, enter 3; quartiles, enter 4; quintiles, 5; deciles, 10.","code":""},{"path":"https://declaredesign.org/r/fabricatr/reference/split_quantile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split data into quantile buckets (e.g. terciles, quartiles, quantiles,\ndeciles). — split_quantile","text":"","code":"# Divide this arbitrary data set in 3. data_input <- rnorm(n = 100) split_quantile(x = data_input, type = 3) #>   [1] 2 3 1 2 2 1 1 2 3 3 3 3 2 1 2 1 1 3 1 1 2 1 3 1 1 3 3 1 1 2 1 3 1 2 2 2 2 #>  [38] 2 2 3 3 1 3 1 3 1 3 2 1 1 1 1 2 3 2 1 1 2 3 3 3 2 3 2 2 3 2 1 2 3 1 2 1 1 #>  [75] 2 1 1 1 2 2 3 1 3 3 2 2 3 3 3 3 3 3 2 1 3 2 1 2 3 2 #> Levels: 1 2 3"},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-100","dir":"Changelog","previous_headings":"","what":"fabricatr 1.0.0","title":"fabricatr 1.0.0","text":"CRAN release: 2022-06-29 draw_categorical() now returns factor category_labels specified. draw_ordered() now returns ordered factor break_labels specified. draw_ordered() performance improved returning factor.","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-0160","dir":"Changelog","previous_headings":"","what":"fabricatr 0.16.0","title":"fabricatr 0.16.0","text":"CRAN release: 2022-02-11 Replacement draw_likert function. join function renamed join_using avoid confusion R functions clearly indicate purpose. Bug fixes.","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-0140","dir":"Changelog","previous_headings":"","what":"fabricatr 0.14.0","title":"fabricatr 0.14.0","text":"CRAN release: 2021-02-09 Bug fixes","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-0120","dir":"Changelog","previous_headings":"","what":"fabricatr 0.12.0","title":"fabricatr 0.12.0","text":"CRAN release: 2021-01-09 Added potential_outcomes (creates multiple columns potential outcomes according formula) Added reveal_outcomes (reveals observed outcomes basis potential outcomes treatment assignment) Added draw_multivariate (interface adding correlated draws fabricate calls)","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-0100","dir":"Changelog","previous_headings":"","what":"fabricatr 0.10.0","title":"fabricatr 0.10.0","text":"CRAN release: 2019-09-04 Changes compatibility rlang 0.4.0 Minor bug fixes","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-080","dir":"Changelog","previous_headings":"","what":"fabricatr 0.8.0","title":"fabricatr 0.8.0","text":"CRAN release: 2019-03-12 Changes prepare R 3.6.0","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-060","dir":"Changelog","previous_headings":"","what":"fabricatr 0.6.0","title":"fabricatr 0.6.0","text":"CRAN release: 2018-08-23 Added split-modify-combine functionality modify_level via argument. Changed behavior draw_ordered ensure categories data-independent adding strict option replaces values NA values outside breaks. Labeled correlate functionality experimental. Many bug fixes.","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-040","dir":"Changelog","previous_headings":"","what":"fabricatr 0.4.0","title":"fabricatr 0.4.0","text":"CRAN release: 2018-03-21 recycle() helper function expanding recycling data Added correlate() function allow users generate arbitrary correlated random variables. Added category_labels argument draw_categorical Added draw_quantile split_quantile functions Major updates test harness Changed ID label stapling behaviour fabricate calls. Allow users pass ID_label level creation calls allow back-door unnamed level calls. Bugfix constants certain modify_level contexts. Changed specification latent variables links; users now provide latent argument using link. New syntax using length(ID) upper level define N lower level. passing vector draw_categorical prob argument, package now sends message instead warning. Major additions documentation vignettes, including vignettes common social sciences variables, time series, using creation packages fabricatr. Bugfix certain cases single-level variables autocompleting “data” working. Added unique_labels argument resample_data allow block-level statistic calculation.","code":""},{"path":"https://declaredesign.org/r/fabricatr/news/index.html","id":"fabricatr-020","dir":"Changelog","previous_headings":"","what":"fabricatr 0.2.0","title":"fabricatr 0.2.0","text":"CRAN release: 2018-01-25 First CRAN submission fabricatr","code":""}]
